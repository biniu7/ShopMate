---
description: 
globs: 
alwaysApply: false
---
Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: src/env.d.ts
================================================
/// <reference types="astro/client" />

import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "./db/database.types";

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
      user:
        | {
            id: string;
            email: string;
          }
        | null;
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string;
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
FILE: src/types.ts
================================================
/**
 * DTO (Data Transfer Object) and Command Model Type Definitions
 *
 * This file contains all DTOs and Command Models used in the ShopMate API.
 * All types are derived from database entity definitions to ensure type safety.
 *
 * Database entities are imported from './db/database.types'
 */

import type { Database } from "./db/database.types";

// ============================================================================
// Database Entity Type Aliases
// ============================================================================

export type Recipe = Database["public"]["Tables"]["recipes"]["Row"];
export type RecipeInsert = Database["public"]["Tables"]["recipes"]["Insert"];
export type RecipeUpdate = Database["public"]["Tables"]["recipes"]["Update"];

export type Ingredient = Database["public"]["Tables"]["ingredients"]["Row"];
export type IngredientInsert = Database["public"]["Tables"]["ingredients"]["Insert"];
export type IngredientUpdate = Database["public"]["Tables"]["ingredients"]["Update"];

export type MealPlan = Database["public"]["Tables"]["meal_plan"]["Row"];
export type MealPlanInsert = Database["public"]["Tables"]["meal_plan"]["Insert"];
export type MealPlanUpdate = Database["public"]["Tables"]["meal_plan"]["Update"];

export type ShoppingList = Database["public"]["Tables"]["shopping_lists"]["Row"];
export type ShoppingListInsert = Database["public"]["Tables"]["shopping_lists"]["Insert"];
export type ShoppingListUpdate = Database["public"]["Tables"]["shopping_lists"]["Update"];

export type ShoppingListItem = Database["public"]["Tables"]["shopping_list_items"]["Row"];
export type ShoppingListItemInsert = Database["public"]["Tables"]["shopping_list_items"]["Insert"];
export type ShoppingListItemUpdate = Database["public"]["Tables"]["shopping_list_items"]["Update"];

// ============================================================================
// Enums and Constants
// ============================================================================

export type MealType = "breakfast" | "second_breakfast" | "lunch" | "dinner";

export type IngredientCategory =
  | "Nabiał" // Dairy
  | "Warzywa" // Vegetables
  | "Owoce" // Fruits
  | "Mięso" // Meat/Fish
  | "Pieczywo" // Bread/Pasta
  | "Przyprawy" // Spices
  | "Inne"; // Other

export const MEAL_TYPES: MealType[] = ["breakfast", "second_breakfast", "lunch", "dinner"];

export const INGREDIENT_CATEGORIES: IngredientCategory[] = [
  "Nabiał",
  "Warzywa",
  "Owoce",
  "Mięso",
  "Pieczywo",
  "Przyprawy",
  "Inne",
];

/**
 * Kolejność kategorii składników (dla sortowania i wyświetlania)
 */
export const CATEGORY_ORDER: IngredientCategory[] = [
  "Nabiał",
  "Warzywa",
  "Owoce",
  "Mięso",
  "Pieczywo",
  "Przyprawy",
  "Inne",
];

// ============================================================================
// Recipe DTOs
// ============================================================================

/**
 * Input DTO for creating or updating ingredients within a recipe
 * Omits database-specific fields (id, recipe_id)
 */
export interface IngredientInputDto {
  name: string;
  quantity: number | null;
  unit: string | null;
  sort_order: number;
}

/**
 * Command Model for creating a new recipe
 * Used in POST /api/recipes
 */
export interface CreateRecipeDto {
  name: string;
  instructions: string;
  ingredients: IngredientInputDto[];
}

/**
 * Command Model for updating a recipe (full replacement)
 * Used in PUT /api/recipes/:id
 */
export type UpdateRecipeDto = CreateRecipeDto;

/**
 * Response DTO for a single ingredient
 * Extends database Ingredient type
 */
export type IngredientResponseDto = Ingredient;

/**
 * Response DTO for a single recipe with nested ingredients
 * Used in GET /api/recipes/:id and POST/PUT responses
 */
export interface RecipeResponseDto extends Recipe {
  ingredients: IngredientResponseDto[];
  meal_plan_assignments?: number; // Count of meal plan assignments
}

/**
 * Response DTO for recipe list items
 * Used in GET /api/recipes (list endpoint)
 */
export interface RecipeListItemDto {
  id: string;
  name: string;
  ingredients_count: number;
  created_at: string;
  updated_at: string;
}

/**
 * Response DTO for recipe deletion
 */
export interface DeleteRecipeResponseDto {
  message: string;
  deleted_meal_plan_assignments: number;
}

// ============================================================================
// Meal Plan DTOs
// ============================================================================

/**
 * Command Model for creating a meal plan assignment
 * Used in POST /api/meal-plan
 */
export interface CreateMealPlanDto {
  recipe_id: string;
  week_start_date: string; // YYYY-MM-DD format
  day_of_week: number; // 1-7 (1 = Monday, 7 = Sunday)
  meal_type: MealType;
}

/**
 * Response DTO for a single meal plan assignment
 * Extends database MealPlan and includes recipe name
 */
export interface MealPlanAssignmentDto {
  id: string;
  user_id: string;
  recipe_id: string;
  recipe_name: string;
  week_start_date: string;
  day_of_week: number;
  meal_type: MealType;
  created_at: string;
}

/**
 * Response DTO for week calendar
 * Used in GET /api/meal-plan
 */
export interface WeekCalendarResponseDto {
  week_start_date: string;
  week_end_date: string;
  assignments: MealPlanAssignmentDto[];
}

/**
 * Response DTO for meal plan assignment deletion
 */
export interface DeleteMealPlanResponseDto {
  message: string;
}

// ============================================================================
// Shopping List DTOs
// ============================================================================

/**
 * Selection for calendar-based shopping list generation
 */
export interface CalendarSelectionDto {
  day_of_week: number;
  meal_types: MealType[];
}

/**
 * Command Model for shopping list preview request (Mode 1: From Calendar)
 * Used in POST /api/shopping-lists/preview
 */
export interface ShoppingListPreviewCalendarRequestDto {
  source: "calendar";
  week_start_date: string;
  selections: CalendarSelectionDto[];
}

/**
 * Command Model for shopping list preview request (Mode 2: From Recipes)
 * Used in POST /api/shopping-lists/preview
 */
export interface ShoppingListPreviewRecipesRequestDto {
  source: "recipes";
  recipe_ids: string[];
}

/**
 * Union type for shopping list preview requests
 */
export type ShoppingListPreviewRequestDto =
  | ShoppingListPreviewCalendarRequestDto
  | ShoppingListPreviewRecipesRequestDto;

/**
 * Item in shopping list preview response
 */
export interface ShoppingListItemPreviewDto {
  ingredient_name: string;
  quantity: number | null;
  unit: string | null;
  category: IngredientCategory;
  sort_order: number;
}

/**
 * Metadata for shopping list preview
 */
export interface ShoppingListPreviewMetadataDto {
  source: "calendar" | "recipes";
  week_start_date?: string;
  total_recipes: number;
  total_items: number;
  ai_categorization_status: "success" | "failed";
  ai_error?: string;
  skipped_empty_meals?: number;
}

/**
 * Response DTO for shopping list preview
 * Used in POST /api/shopping-lists/preview response
 */
export interface ShoppingListPreviewResponseDto {
  items: ShoppingListItemPreviewDto[];
  metadata: ShoppingListPreviewMetadataDto;
}

/**
 * Input DTO for shopping list item when saving
 */
export interface SaveShoppingListItemDto {
  ingredient_name: string;
  quantity?: number | null;
  unit?: string | null;
  category: IngredientCategory;
  sort_order: number;
}

/**
 * Command Model for saving a shopping list
 * Used in POST /api/shopping-lists
 */
export interface SaveShoppingListDto {
  name: string;
  week_start_date?: string | null;
  items: SaveShoppingListItemDto[];
}

/**
 * Response DTO for a shopping list item
 * Extends database ShoppingListItem type
 */
export type ShoppingListItemDto = ShoppingListItem;

/**
 * Response DTO for a complete shopping list with items
 * Used in GET /api/shopping-lists/:id and POST response
 */
export interface ShoppingListResponseDto extends ShoppingList {
  items: ShoppingListItemDto[];
}

/**
 * Response DTO for shopping list in list view
 * Used in GET /api/shopping-lists (list endpoint)
 */
export interface ShoppingListListItemDto {
  id: string;
  name: string;
  week_start_date: string | null;
  items_count: number;
  created_at: string;
}

/**
 * Command Model for updating a shopping list item (check/uncheck)
 * Used in PATCH /api/shopping-lists/:list_id/items/:item_id
 */
export interface UpdateShoppingListItemDto {
  is_checked: boolean;
}

/**
 * Response DTO for shopping list deletion
 */
export interface DeleteShoppingListResponseDto {
  message: string;
}

// ============================================================================
// Pagination DTOs
// ============================================================================

/**
 * Query parameters for pagination
 */
export interface PaginationParams {
  page?: number;
  limit?: number;
}

/**
 * Pagination metadata in responses
 */
export interface PaginationMetadata {
  page: number;
  limit: number;
  total: number;
  total_pages: number;
}

/**
 * Generic paginated response wrapper
 */
export interface PaginatedResponse<T> {
  data: T[];
  pagination: PaginationMetadata;
}

// ============================================================================
// Query Parameter DTOs
// ============================================================================

/**
 * Query parameters for recipe list endpoint
 * Used in GET /api/recipes
 */
export interface RecipeListQueryParams extends PaginationParams {
  search?: string;
  sort?: "name_asc" | "name_desc" | "created_asc" | "created_desc";
}

/**
 * Query parameters for meal plan endpoint
 * Used in GET /api/meal-plan
 */
export interface MealPlanQueryParams {
  week_start_date: string; // YYYY-MM-DD
}

/**
 * Query parameters for shopping list list endpoint
 * Used in GET /api/shopping-lists
 */
export type ShoppingListQueryParams = PaginationParams;

// ============================================================================
// Error Response DTOs
// ============================================================================

/**
 * Standard error response
 */
export interface ErrorResponseDto {
  error: string;
  message?: string;
}

/**
 * Validation error details
 */
export type ValidationErrorDetails = Record<string, string[]>;

/**
 * Validation error response
 */
export interface ValidationErrorResponseDto {
  error: string;
  details: ValidationErrorDetails;
}

// ============================================================================
// Analytics DTOs
// ============================================================================

/**
 * Command Model for tracking export events
 * Used in POST /api/analytics/export
 */
export interface TrackExportDto {
  shopping_list_id: string;
  format: "pdf" | "txt";
}

// ============================================================================
// Utility Types
// ============================================================================

/**
 * Extracts the week start date from a given date (returns Monday)
 */
export type WeekStartDate = string; // YYYY-MM-DD format, always Monday

/**
 * ISO date string format
 */
export type ISODateString = string; // YYYY-MM-DD

/**
 * ISO datetime string format
 */
export type ISODateTimeString = string; // ISO 8601 format

/**
 * UUID string format
 */
export type UUID = string;

// ============================================================================
// API Response Types (Helper types for common response patterns)
// ============================================================================

/**
 * Success response with data
 */
export interface SuccessResponse<T> {
  data: T;
}

/**
 * Created response (201)
 */
export type CreatedResponse<T> = T;

/**
 * No content response (204)
 */
export type NoContentResponse = Record<string, never>;

/**
 * Message-only response
 */
export interface MessageResponse {
  message: string;
}

// ============================================================================
// Calendar View Models (Frontend)
// ============================================================================

/**
 * State tygodnia kalendarza
 */
export interface WeekState {
  weekStartDate: string; // YYYY-MM-DD (Monday)
  weekEndDate: string; // YYYY-MM-DD (Sunday)
  dateRange: string; // "20-26 stycznia 2025" (formatted for display)
}

/**
 * ViewModel dla pojedynczej komórki kalendarza
 * Łączy informacje o dacie, posiłku i przypisaniu
 */
export interface CalendarCellViewModel {
  date: Date; // Full date object
  dateString: string; // YYYY-MM-DD
  dayOfWeek: number; // 1-7 (1=Monday)
  dayName: string; // "Poniedziałek", "Wtorek", ...
  dayNameShort: string; // "Pon", "Wt", ...
  mealType: MealType;
  mealTypeLabel: string; // "Śniadanie", "Drugie śniadanie", "Obiad", "Kolacja"
  assignment: MealPlanAssignmentDto | null;
  isEmpty: boolean; // true if assignment === null
}

/**
 * State modala wyboru przepisu
 */
export interface RecipePickerState {
  isOpen: boolean;
  targetCell: {
    dayOfWeek: number;
    mealType: MealType;
    date: Date;
  } | null;
}

/**
 * State podglądu przepisu
 */
export interface RecipePreviewState {
  isOpen: boolean;
  recipeId: string | null;
  assignmentId: string | null; // Do usunięcia z kalendarza
}

/**
 * Stan całego komponentu Calendar
 */
export interface CalendarState {
  // Week navigation
  weekStartDate: string;
  weekEndDate: string;
  dateRange: string;

  // Assignments
  assignments: MealPlanAssignmentDto[];
  isLoading: boolean;
  error: Error | null;

  // Modals
  recipePicker: RecipePickerState;
  recipePreview: RecipePreviewState;
}

/**
 * Parametry wyszukiwania przepisów w modalu
 */
export interface RecipeSearchParams {
  search: string;
  page: number;
  limit: number;
}

/**
 * Typ dla handlera zmiany tygodnia
 */
export type WeekChangeHandler = (newWeekStart: string) => void;

/**
 * Typ dla handlera przypisania przepisu
 */
export type AssignRecipeHandler = (dayOfWeek: number, mealType: MealType, recipeId: string) => Promise<void>;

/**
 * Typ dla handlera usunięcia przypisania
 */
export type RemoveAssignmentHandler = (assignmentId: string) => Promise<void>;

// ============================================================================
// Dashboard View Models
// ============================================================================

/**
 * Statystyki dashboardu
 */
export interface DashboardStats {
  /** Całkowita liczba przepisów użytkownika */
  recipesCount: number;
  /** Liczba przypisań posiłków w bieżącym tygodniu */
  mealPlansCount: number;
  /** Całkowita liczba zapisanych list zakupów */
  shoppingListsCount: number;
}

/**
 * ViewModel dla nadchodzącego posiłku w timeline
 */
export interface UpcomingMealViewModel {
  /** Etykieta dnia: "Dzisiaj" lub "Jutro" */
  day: string;
  /** Sformatowana data (np. "20 stycznia") */
  date: string;
  /** ISO date string dla sortowania */
  isoDate: string;
  /** Dzień tygodnia (1-7) */
  dayOfWeek: number;
  /** Typ posiłku (breakfast, lunch, etc.) */
  mealType: MealType;
  /** Polska etykieta typu posiłku (np. "Śniadanie") */
  mealTypeLabel: string;
  /** Nazwa przypisanego przepisu */
  recipeName: string;
  /** ID przypisanego przepisu */
  recipeId: string;
  /** Porządek sortowania (0-7, gdzie 0 = dziś śniadanie, 7 = jutro kolacja) */
  sortOrder: number;
}

/**
 * Kompletne dane dla widoku Dashboard
 */
export interface DashboardData {
  /** Statystyki (liczby) */
  stats: DashboardStats;
  /** 3 ostatnio dodane przepisy */
  recentRecipes: RecipeListItemDto[];
  /** Posiłki na dziś i jutro */
  upcomingMeals: UpcomingMealViewModel[];
  /** Czy użytkownik jest nowy (0 przepisów) */
  isNewUser: boolean;
  /** Czy dane się ładują */
  isLoading: boolean;
  /** Błąd jeśli wystąpił */
  error: Error | null;
}

/**
 * Mapowanie typu posiłku na polską etykietę
 */
export const MEAL_TYPE_LABELS: Record<MealType, string> = {
  breakfast: "Śniadanie",
  second_breakfast: "Drugie śniadanie",
  lunch: "Obiad",
  dinner: "Kolacja",
};

/**
 * Kolejność typów posiłków (dla sortowania)
 */
export const MEAL_TYPE_ORDER: Record<MealType, number> = {
  breakfast: 0,
  second_breakfast: 1,
  lunch: 2,
  dinner: 3,
};

// ============================================================================
// Recipes List View Models
// ============================================================================

/**
 * Opcje sortowania dla listy przepisów
 */
export type RecipeSortOption = "name_asc" | "name_desc" | "created_asc" | "created_desc";

/**
 * Labels dla opcji sortowania (UI)
 */
export const RECIPE_SORT_LABELS: Record<RecipeSortOption, string> = {
  name_asc: "Alfabetycznie A-Z",
  name_desc: "Alfabetycznie Z-A",
  created_asc: "Najstarsze",
  created_desc: "Najnowsze",
};

/**
 * Stan URL query params dla Recipes List
 */
export interface RecipesListUrlParams {
  search?: string;
  sort?: RecipeSortOption;
}

/**
 * Stan wewnętrzny widoku Recipes List
 */
export interface RecipesListState {
  /** Fraza wyszukiwania */
  search: string;
  /** Typ sortowania */
  sort: RecipeSortOption;
  /** Całkowita liczba przepisów (z pagination) */
  totalRecipes: number;
  /** Płaska lista przepisów ze wszystkich stron */
  recipes: RecipeListItemDto[];
  /** Czy są kolejne strony do załadowania */
  hasNextPage: boolean;
  /** Czy trwa ładowanie pierwszej strony */
  isLoading: boolean;
  /** Czy trwa ładowanie kolejnej strony */
  isFetchingNextPage: boolean;
  /** Błąd jeśli wystąpił */
  error: Error | null;
}

/**
 * Response dla infinite query
 */
export interface RecipesPageResponse {
  data: RecipeListItemDto[];
  pagination: PaginationMetadata;
  nextPage: number | undefined;
}



================================================
FILE: src/components/Calendar.tsx
================================================
/**
 * Main Calendar Component
 * Weekly meal planner calendar view
 */
import { lazy, Suspense } from "react";
import { QueryProvider } from "@/components/providers/QueryProvider";
import { WeekNavigator } from "@/components/WeekNavigator";
import { CalendarGrid } from "@/components/CalendarGrid";
import { useCalendar } from "@/components/hooks/useCalendar";
import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";

// Lazy load modals for better performance
const RecipePickerModal = lazy(() => import("@/components/RecipePickerModal"));
const RecipePreviewModal = lazy(() => import("@/components/RecipePreviewModal"));

/**
 * Calendar Loading Skeleton
 * Displayed while calendar data is loading
 */
function CalendarSkeleton() {
  return (
    <div className="calendar-skeleton" aria-busy="true" aria-label="Ładowanie kalendarza">
      {/* Week Navigator Skeleton */}
      <div className="sticky top-0 z-10 bg-white border-b shadow-sm mb-6">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between gap-4">
            <Skeleton className="h-10 w-40" />
            <Skeleton className="h-12 w-48" />
            <Skeleton className="h-10 w-40" />
          </div>
        </div>
      </div>

      {/* Calendar Grid Skeleton */}
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-7 gap-4">
          {Array.from({ length: 28 }).map((_, i) => (
            <Skeleton key={i} className="h-32 w-full" />
          ))}
        </div>
      </div>
    </div>
  );
}

/**
 * Calendar Error State
 * Displayed when calendar data fails to load
 */
function CalendarError({ error, onRetry }: { error: Error | null; onRetry: () => void }) {
  return (
    <div className="error-state text-center p-8 max-w-md mx-auto" role="alert" aria-live="assertive">
      <div className="mb-4">
        <svg
          className="w-16 h-16 mx-auto text-red-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          />
        </svg>
      </div>
      <h2 className="text-xl font-semibold text-gray-900 mb-2">Nie udało się załadować kalendarza</h2>
      <p className="text-gray-600 mb-6">
        {error?.message || "Wystąpił błąd podczas ładowania danych. Spróbuj ponownie."}
      </p>
      <Button onClick={onRetry} variant="default">
        Spróbuj ponownie
      </Button>
    </div>
  );
}

/**
 * Calendar Empty State
 * Displayed when calendar has no assignments
 */
function CalendarEmptyState({ onAssignFirst }: { onAssignFirst: () => void }) {
  return (
    <div className="empty-state text-center p-12 max-w-md mx-auto">
      <div className="mb-4">
        <svg
          className="w-16 h-16 mx-auto text-gray-400"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
          />
        </svg>
      </div>
      <h3 className="text-xl font-semibold text-gray-900 mb-2">Twój kalendarz jest pusty</h3>
      <p className="text-gray-600 mb-6">Zacznij planować posiłki klikając "Przypisz przepis" w wybranej komórce</p>
      <Button onClick={onAssignFirst} variant="default">
        Przypisz pierwszy przepis
      </Button>
    </div>
  );
}

/**
 * Calendar Content
 * Main calendar content with data
 */
function CalendarContent() {
  const {
    // State
    weekStartDate,
    dateRange,
    assignments,
    cells,
    isLoading,
    error,
    refetch,

    // Modal states
    recipePickerState,
    recipePreviewState,

    // Handlers
    handleWeekChange,
    handleAssignRecipe,
    handleRecipeSelected,
    handleRemoveAssignment,
    handlePreviewRecipe,

    // Modal controllers
    closeRecipePicker,
    closeRecipePreview,
  } = useCalendar();

  // Loading state
  if (isLoading) {
    return <CalendarSkeleton />;
  }

  // Error state
  if (error) {
    return <CalendarError error={error} onRetry={() => refetch()} />;
  }

  const hasAnyAssignments = assignments.length > 0;

  return (
    <div className="calendar-container min-h-screen bg-gray-50">
      {/* Week Navigator */}
      <WeekNavigator weekStartDate={weekStartDate} onWeekChange={handleWeekChange} dateRange={dateRange} />

      {/* Calendar Grid */}
      <div className="container mx-auto px-4 py-6">
        {!hasAnyAssignments ? (
          <CalendarEmptyState onAssignFirst={() => handleAssignRecipe(1, "breakfast")} />
        ) : (
          <CalendarGrid
            weekStartDate={weekStartDate}
            cells={cells}
            onAssignRecipe={handleAssignRecipe}
            onRemoveAssignment={handleRemoveAssignment}
            onPreviewRecipe={handlePreviewRecipe}
          />
        )}
      </div>

      {/* Modals - Lazy Loaded */}
      <Suspense fallback={null}>
        {recipePickerState.isOpen && (
          <RecipePickerModal
            isOpen={recipePickerState.isOpen}
            onClose={closeRecipePicker}
            targetCell={recipePickerState.targetCell}
            weekStartDate={weekStartDate}
            onRecipeSelected={handleRecipeSelected}
          />
        )}
      </Suspense>

      <Suspense fallback={null}>
        {recipePreviewState.isOpen && (
          <RecipePreviewModal
            isOpen={recipePreviewState.isOpen}
            onClose={closeRecipePreview}
            recipeId={recipePreviewState.recipeId}
            assignmentId={recipePreviewState.assignmentId}
            onRemoveFromCalendar={handleRemoveAssignment}
          />
        )}
      </Suspense>
    </div>
  );
}

/**
 * Main Calendar Component with QueryProvider
 */
export default function Calendar() {
  return (
    <QueryProvider>
      <CalendarContent />
    </QueryProvider>
  );
}



================================================
FILE: src/components/CalendarGrid.tsx
================================================
/**
 * Calendar Grid Component
 * Responsive grid layout for calendar cells
 * Desktop: 7×4 grid, Tablet: horizontal scroll, Mobile: accordion
 */
import { memo, useMemo } from "react";
import { MealCell } from "./MealCell";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import type { MealType } from "@/types";
import type { CalendarCellViewModel } from "@/lib/utils/calendar";
import { groupCellsByDay } from "@/lib/utils/calendar";

interface CalendarGridProps {
  weekStartDate: string;
  cells: CalendarCellViewModel[];
  onAssignRecipe: (dayOfWeek: number, mealType: MealType) => void;
  onRemoveAssignment: (assignmentId: string) => void;
  onPreviewRecipe: (recipeId: string, assignmentId: string) => void;
}

/**
 * Calendar Grid Component
 * Renders calendar with responsive layouts
 */
export const CalendarGrid = memo<CalendarGridProps>(
  ({ cells, onAssignRecipe, onRemoveAssignment, onPreviewRecipe }) => {
    // Group cells by day for tablet/mobile layouts
    const cellsByDay = useMemo(() => groupCellsByDay(cells), [cells]);

    // Get array of days (1-7)
    const days = useMemo(() => Array.from({ length: 7 }, (_, i) => i + 1), []);

    return (
      <div className="calendar-grid-container">
        {/* Desktop Layout (≥1024px) - CSS Grid 7×4 */}
        <div className="hidden lg:block" role="grid" aria-label="Kalendarz posiłków">
          {/* Day Headers */}
          <div className="grid grid-cols-7 gap-4 mb-4">
            {days.map((dayOfWeek) => {
              const dayCells = cellsByDay.get(dayOfWeek) || [];
              const firstCell = dayCells[0];
              if (!firstCell) return null;

              return (
                <div
                  key={dayOfWeek}
                  className="text-center font-semibold text-gray-700 py-2 border-b-2 border-gray-300"
                  role="columnheader"
                >
                  <div className="text-sm">{firstCell.dayNameShort}</div>
                  <div className="text-xs text-gray-500">
                    {firstCell.date.getDate()}.{firstCell.date.getMonth() + 1}
                  </div>
                </div>
              );
            })}
          </div>

          {/* Calendar Grid - 7 columns × 4 rows */}
          <div className="grid grid-cols-7 gap-4">
            {cells.map((cell) => (
              <MealCell
                key={`${cell.dayOfWeek}-${cell.mealType}`}
                date={cell.date}
                dayOfWeek={cell.dayOfWeek}
                mealType={cell.mealType}
                mealTypeLabel={cell.mealTypeLabel}
                assignment={cell.assignment}
                onAssignRecipe={onAssignRecipe}
                onRemoveAssignment={onRemoveAssignment}
                onPreviewRecipe={onPreviewRecipe}
              />
            ))}
          </div>
        </div>

        {/* Tablet Layout (768-1023px) - Horizontal Scroll */}
        <div className="hidden md:block lg:hidden overflow-x-auto" role="grid" aria-label="Kalendarz posiłków">
          <div className="flex gap-4 pb-4" style={{ minWidth: "max-content" }}>
            {days.map((dayOfWeek) => {
              const dayCells = cellsByDay.get(dayOfWeek) || [];
              const firstCell = dayCells[0];
              if (!firstCell) return null;

              return (
                <div key={dayOfWeek} className="flex-shrink-0 w-64" role="columnheader">
                  {/* Day Header */}
                  <div className="text-center font-semibold text-gray-700 py-3 mb-4 border-b-2 border-gray-300 sticky top-0 bg-white z-10">
                    <div className="text-base">{firstCell.dayName}</div>
                    <div className="text-sm text-gray-500">
                      {firstCell.date.getDate()}.{firstCell.date.getMonth() + 1}.{firstCell.date.getFullYear()}
                    </div>
                  </div>

                  {/* Meals for this day */}
                  <div className="space-y-3">
                    {dayCells.map((cell) => (
                      <MealCell
                        key={`${cell.dayOfWeek}-${cell.mealType}`}
                        date={cell.date}
                        dayOfWeek={cell.dayOfWeek}
                        mealType={cell.mealType}
                        mealTypeLabel={cell.mealTypeLabel}
                        assignment={cell.assignment}
                        onAssignRecipe={onAssignRecipe}
                        onRemoveAssignment={onRemoveAssignment}
                        onPreviewRecipe={onPreviewRecipe}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {/* Mobile Layout (<768px) - Accordion */}
        <div className="md:hidden" role="region" aria-label="Kalendarz posiłków">
          <Accordion type="single" collapsible className="w-full">
            {days.map((dayOfWeek) => {
              const dayCells = cellsByDay.get(dayOfWeek) || [];
              const firstCell = dayCells[0];
              if (!firstCell) return null;

              // Count assigned meals for badge
              const assignedCount = dayCells.filter((cell) => !cell.isEmpty).length;

              return (
                <AccordionItem key={dayOfWeek} value={`day-${dayOfWeek}`}>
                  <AccordionTrigger className="hover:no-underline">
                    <div className="flex items-center justify-between w-full pr-4">
                      <div className="text-left">
                        <div className="font-semibold text-gray-900">{firstCell.dayName}</div>
                        <div className="text-sm text-gray-500">
                          {firstCell.date.getDate()}.{firstCell.date.getMonth() + 1}.{firstCell.date.getFullYear()}
                        </div>
                      </div>
                      {assignedCount > 0 && (
                        <span className="inline-flex items-center justify-center w-6 h-6 text-xs font-medium text-white bg-blue-600 rounded-full">
                          {assignedCount}
                        </span>
                      )}
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="space-y-3 pt-2">
                      {dayCells.map((cell) => (
                        <MealCell
                          key={`${cell.dayOfWeek}-${cell.mealType}`}
                          date={cell.date}
                          dayOfWeek={cell.dayOfWeek}
                          mealType={cell.mealType}
                          mealTypeLabel={cell.mealTypeLabel}
                          assignment={cell.assignment}
                          onAssignRecipe={onAssignRecipe}
                          onRemoveAssignment={onRemoveAssignment}
                          onPreviewRecipe={onPreviewRecipe}
                        />
                      ))}
                    </div>
                  </AccordionContent>
                </AccordionItem>
              );
            })}
          </Accordion>
        </div>
      </div>
    );
  }
);

CalendarGrid.displayName = "CalendarGrid";



================================================
FILE: src/components/MealCell.tsx
================================================
/**
 * Meal Cell Component
 * Single cell in the calendar grid representing one meal
 */
import { memo } from "react";
import { Button } from "@/components/ui/button";
import type { MealPlanAssignmentDto, MealType } from "@/types";
import { truncateText } from "@/lib/utils/calendar";

interface MealCellProps {
  date: Date;
  dayOfWeek: number; // 1-7
  mealType: MealType;
  mealTypeLabel: string;
  assignment: MealPlanAssignmentDto | null;
  onAssignRecipe: (dayOfWeek: number, mealType: MealType) => void;
  onRemoveAssignment: (assignmentId: string) => void;
  onPreviewRecipe: (recipeId: string, assignmentId: string) => void;
}

/**
 * Meal Cell Component
 * Displays empty state or assigned recipe
 */
export const MealCell = memo<MealCellProps>(
  ({ dayOfWeek, mealType, mealTypeLabel, assignment, onAssignRecipe, onRemoveAssignment, onPreviewRecipe }) => {
    // Empty state - no assignment
    if (!assignment) {
      return (
        <div
          className="meal-cell empty border-2 border-dashed border-gray-300 rounded-lg p-4 bg-gray-50 hover:bg-gray-100 transition-colors"
          role="gridcell"
        >
          <p className="text-sm text-gray-500 font-medium mb-2">{mealTypeLabel}</p>
          <Button
            variant="secondary"
            size="sm"
            onClick={() => onAssignRecipe(dayOfWeek, mealType)}
            className="w-full text-xs"
            aria-label={`Przypisz przepis do ${mealTypeLabel}`}
          >
            + Przypisz przepis
          </Button>
        </div>
      );
    }

    // Assigned state - has recipe
    return (
      <div
        className="meal-cell assigned border border-gray-200 rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow"
        role="gridcell"
      >
        <p className="text-sm text-gray-500 font-medium mb-2">{mealTypeLabel}</p>
        <div className="flex items-start justify-between gap-2">
          <button
            className="text-sm font-medium text-gray-900 hover:text-blue-600 hover:underline cursor-pointer text-left flex-1 min-w-0 transition-colors"
            onClick={() => onPreviewRecipe(assignment.recipe_id, assignment.id)}
            title={assignment.recipe_name}
            aria-label={`Podgląd przepisu: ${assignment.recipe_name}`}
          >
            <span className="block truncate">{truncateText(assignment.recipe_name, 30)}</span>
          </button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onRemoveAssignment(assignment.id)}
            className="text-red-600 hover:text-red-800 hover:bg-red-50 p-1 h-auto min-w-0 flex-shrink-0"
            aria-label={`Usuń przypisanie: ${assignment.recipe_name}`}
          >
            <span className="text-lg leading-none">×</span>
          </Button>
        </div>
      </div>
    );
  }
);

MealCell.displayName = "MealCell";



================================================
FILE: src/components/Navigation.tsx
================================================
/**
 * Navigation Component
 *
 * Based on spec 31_1_auth-spec.md section 2.2.2
 *
 * Features:
 * - Responsive navigation (desktop horizontal menu, mobile hamburger)
 * - Logout button for authenticated users
 * - Login/Register buttons for guests
 * - Loading state during logout
 */

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

interface NavigationProps {
  user: {
    id: string;
    email: string;
  } | null;
}

export default function Navigation({ user }: NavigationProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const handleLogout = async () => {
    setIsLoading(true);

    try {
      // Call server-side logout API endpoint
      const response = await fetch("/api/auth/logout", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        // Server returned error
        const errorMessage = data.error || "Nie udało się wylogować";
        toast.error(errorMessage);
        setIsLoading(false);
        return;
      }

      // Success - session cleared on server
      toast.success("Zostałeś wylogowany");

      // Redirect to login page
      window.location.href = "/login";
    } catch (error) {
      console.error("Logout error:", error);
      toast.error("Brak połączenia. Sprawdź internet i spróbuj ponownie.");
      setIsLoading(false);
    }
  };

  return (
    <nav className="bg-white shadow-sm border-b">
      <div className="container mx-auto px-4">
        <div className="flex items-center justify-between h-16">
          {/* Logo */}
          <a
            href={user ? "/dashboard" : "/"}
            className="text-2xl font-bold text-primary hover:opacity-80 transition-opacity"
          >
            ShopMate
          </a>

          {/* Desktop Navigation */}
          <div className="hidden md:flex items-center space-x-6">
            {user ? (
              <>
                {/* Authenticated user menu */}
                <a
                  href="/dashboard"
                  className="text-gray-700 hover:text-primary transition-colors"
                >
                  Dashboard
                </a>
                <a
                  href="/recipes"
                  className="text-gray-700 hover:text-primary transition-colors"
                >
                  Przepisy
                </a>
                <a
                  href="/calendar"
                  className="text-gray-700 hover:text-primary transition-colors"
                >
                  Kalendarz
                </a>
                <a
                  href="/shopping-lists"
                  className="text-gray-700 hover:text-primary transition-colors"
                >
                  Listy zakupów
                </a>

                {/* Logout button */}
                <Button onClick={handleLogout} variant="outline" disabled={isLoading}>
                  {isLoading ? "Wylogowuj..." : "Wyloguj"}
                </Button>
              </>
            ) : (
              <>
                {/* Guest menu */}
                <a href="/login">
                  <Button variant="outline">Zaloguj się</Button>
                </a>
                <a href="/register">
                  <Button>Zarejestruj się</Button>
                </a>
              </>
            )}
          </div>

          {/* Mobile hamburger button */}
          <button
            onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
            className="md:hidden p-2 rounded-md hover:bg-gray-100 transition-colors"
            aria-label="Toggle menu"
            aria-expanded={isMobileMenuOpen}
          >
            <svg
              className="w-6 h-6"
              fill="none"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              {isMobileMenuOpen ? (
                <path d="M6 18L18 6M6 6l12 12" />
              ) : (
                <path d="M4 6h16M4 12h16M4 18h16" />
              )}
            </svg>
          </button>
        </div>

        {/* Mobile Navigation Menu */}
        {isMobileMenuOpen && (
          <div className="md:hidden py-4 border-t">
            {user ? (
              <div className="flex flex-col space-y-3">
                <a
                  href="/dashboard"
                  className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
                >
                  Dashboard
                </a>
                <a
                  href="/recipes"
                  className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
                >
                  Przepisy
                </a>
                <a
                  href="/calendar"
                  className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
                >
                  Kalendarz
                </a>
                <a
                  href="/shopping-lists"
                  className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
                >
                  Listy zakupów
                </a>
                <div className="px-4 pt-2">
                  <Button
                    onClick={handleLogout}
                    variant="outline"
                    className="w-full"
                    disabled={isLoading}
                  >
                    {isLoading ? "Wylogowuj..." : "Wyloguj"}
                  </Button>
                </div>
              </div>
            ) : (
              <div className="flex flex-col space-y-3 px-4">
                <a href="/login" className="w-full">
                  <Button variant="outline" className="w-full">
                    Zaloguj się
                  </Button>
                </a>
                <a href="/register" className="w-full">
                  <Button className="w-full">Zarejestruj się</Button>
                </a>
              </div>
            )}
          </div>
        )}
      </div>
    </nav>
  );
}


================================================
FILE: src/components/RecipePickerModal.tsx
================================================
/**
 * Recipe Picker Modal Component
 * Modal for selecting a recipe to assign to a meal
 */
import { memo, useCallback, useRef, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { SearchBar } from "@/components/SearchBar";
import { useRecipeSearch } from "@/components/hooks/useRecipeSearch";
import type { MealType } from "@/types";
import { getMealTypeLabel, getDayName } from "@/lib/utils/date";

interface RecipePickerModalProps {
  isOpen: boolean;
  onClose: () => void;
  targetCell: {
    dayOfWeek: number;
    mealType: MealType;
    date: Date;
  } | null;
  weekStartDate: string;
  onRecipeSelected: (recipeId: string) => void;
}

/**
 * Recipe Card Component
 * Clickable card for selecting a recipe
 */
const RecipeCard = memo<{
  id: string;
  name: string;
  ingredientsCount: number;
  onClick: () => void;
}>(({ id, name, ingredientsCount, onClick }) => {
  return (
    <button
      onClick={onClick}
      className="w-full text-left p-4 border border-gray-200 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      aria-label={`Wybierz przepis: ${name}`}
    >
      <h3 className="font-medium text-gray-900 mb-1">{name}</h3>
      <p className="text-sm text-gray-500">
        {ingredientsCount} {ingredientsCount === 1 ? "składnik" : "składników"}
      </p>
    </button>
  );
});

RecipeCard.displayName = "RecipeCard";

/**
 * Recipe Picker Modal Component
 * Modal with search, infinite scroll, and recipe selection
 */
const RecipePickerModal = memo<RecipePickerModalProps>(
  ({ isOpen, onClose, targetCell, weekStartDate, onRecipeSelected }) => {
    const { searchQuery, setSearchQuery, recipes, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, error } =
      useRecipeSearch();

    // Intersection Observer for infinite scroll
    const loadMoreRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
      if (!loadMoreRef.current || !hasNextPage || isFetchingNextPage) return;

      const observer = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting) {
            fetchNextPage();
          }
        },
        { threshold: 0.1 }
      );

      observer.observe(loadMoreRef.current);

      return () => observer.disconnect();
    }, [hasNextPage, isFetchingNextPage, fetchNextPage]);

    // Handle recipe selection
    const handleSelectRecipe = useCallback(
      (recipeId: string) => {
        onRecipeSelected(recipeId);
      },
      [onRecipeSelected]
    );

    // Get target cell display name
    const targetCellDisplay = targetCell
      ? `${getDayName(targetCell.dayOfWeek)} - ${getMealTypeLabel(targetCell.mealType)}`
      : "";

    return (
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-3xl max-h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle>Wybierz przepis</DialogTitle>
            <DialogDescription>{targetCell && `Przypisujesz przepis do: ${targetCellDisplay}`}</DialogDescription>
          </DialogHeader>

          {/* Search Bar */}
          <div className="py-4">
            <SearchBar value={searchQuery} onChange={setSearchQuery} placeholder="Szukaj przepisu..." />
          </div>

          {/* Recipe List */}
          <ScrollArea className="flex-1 h-[400px] -mx-6 px-6">
            {isLoading && (
              <div className="text-center py-8 text-gray-500">
                <div className="animate-spin w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mx-auto mb-2" />
                Ładowanie przepisów...
              </div>
            )}

            {error && (
              <div className="text-center py-8 text-red-600">Nie udało się załadować przepisów. Spróbuj ponownie.</div>
            )}

            {!isLoading && !error && recipes.length === 0 && (
              <div className="text-center py-8 text-gray-500">
                {searchQuery
                  ? `Nie znaleziono przepisów dla: "${searchQuery}"`
                  : "Brak przepisów. Dodaj pierwszy przepis!"}
              </div>
            )}

            {!isLoading && !error && recipes.length > 0 && (
              <div className="space-y-3">
                {recipes.map((recipe) => (
                  <RecipeCard
                    key={recipe.id}
                    id={recipe.id}
                    name={recipe.name}
                    ingredientsCount={recipe.ingredients_count}
                    onClick={() => handleSelectRecipe(recipe.id)}
                  />
                ))}

                {/* Load More Trigger */}
                {hasNextPage && (
                  <div ref={loadMoreRef} className="text-center py-4">
                    {isFetchingNextPage ? (
                      <div className="animate-spin w-6 h-6 border-4 border-blue-600 border-t-transparent rounded-full mx-auto" />
                    ) : (
                      <p className="text-sm text-gray-500">Przewiń, aby załadować więcej</p>
                    )}
                  </div>
                )}
              </div>
            )}
          </ScrollArea>

          {/* Footer */}
          <DialogFooter>
            <Button variant="outline" onClick={onClose}>
              Anuluj
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }
);

RecipePickerModal.displayName = "RecipePickerModal";

export default RecipePickerModal;



================================================
FILE: src/components/RecipePreviewModal.tsx
================================================
/**
 * Recipe Preview Modal Component
 * Modal for viewing recipe details from calendar
 */
import { memo } from "react";
import { useQuery } from "@tanstack/react-query";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { fetchRecipe } from "@/lib/api/recipes";
import type { RecipeResponseDto } from "@/types";

interface RecipePreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  recipeId: string | null;
  assignmentId: string | null;
  onRemoveFromCalendar: (assignmentId: string) => void;
}

/**
 * Recipe Preview Modal Component
 * Displays recipe details with actions
 */
const RecipePreviewModal = memo<RecipePreviewModalProps>(
  ({ isOpen, onClose, recipeId, assignmentId, onRemoveFromCalendar }) => {
    // Fetch recipe details
    const {
      data: recipe,
      isLoading,
      error,
    } = useQuery<RecipeResponseDto>({
      queryKey: ["recipe", recipeId],
      queryFn: () => fetchRecipe(recipeId!),
      enabled: !!recipeId && isOpen,
      staleTime: 5 * 60 * 1000, // 5 minutes
    });

    // Handle remove from calendar
    const handleRemoveFromCalendar = () => {
      if (assignmentId) {
        onRemoveFromCalendar(assignmentId);
        onClose();
      }
    };

    // Handle edit recipe
    const handleEditRecipe = () => {
      if (recipeId) {
        window.location.href = `/recipes/${recipeId}/edit`;
      }
    };

    return (
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-2xl max-h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle>{recipe?.name || "Podgląd przepisu"}</DialogTitle>
            {recipe && (
              <DialogDescription>
                {recipe.ingredients.length} {recipe.ingredients.length === 1 ? "składnik" : "składników"}
              </DialogDescription>
            )}
          </DialogHeader>

          {/* Content */}
          <ScrollArea className="flex-1 h-[500px] -mx-6 px-6">
            {isLoading && (
              <div className="text-center py-8 text-gray-500">
                <div className="animate-spin w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mx-auto mb-2" />
                Ładowanie przepisu...
              </div>
            )}

            {error && (
              <div className="text-center py-8 text-red-600">Nie udało się załadować przepisu. Spróbuj ponownie.</div>
            )}

            {recipe && (
              <div className="space-y-6">
                {/* Ingredients Section */}
                <section>
                  <h3 className="font-semibold text-lg text-gray-900 mb-3">Składniki ({recipe.ingredients.length})</h3>
                  <ul className="list-disc pl-5 space-y-2">
                    {recipe.ingredients.map((ingredient) => (
                      <li key={ingredient.id} className="text-gray-700">
                        {ingredient.quantity && ingredient.unit ? (
                          <>
                            <span className="font-medium">
                              {ingredient.quantity} {ingredient.unit}
                            </span>{" "}
                            {ingredient.name}
                          </>
                        ) : (
                          <span className="font-medium">{ingredient.name}</span>
                        )}
                      </li>
                    ))}
                  </ul>
                </section>

                {/* Instructions Section */}
                <section>
                  <h3 className="font-semibold text-lg text-gray-900 mb-3">Instrukcje</h3>
                  <p className="text-gray-700 whitespace-pre-wrap leading-relaxed">{recipe.instructions}</p>
                </section>

                {/* Metadata */}
                {recipe.meal_plan_assignments !== undefined && (
                  <section className="pt-4 border-t border-gray-200">
                    <p className="text-sm text-gray-500">
                      Przepis przypisany do {recipe.meal_plan_assignments}{" "}
                      {recipe.meal_plan_assignments === 1 ? "posiłku" : "posiłków"}
                    </p>
                  </section>
                )}
              </div>
            )}
          </ScrollArea>

          {/* Footer with Actions */}
          <DialogFooter className="space-x-2">
            <Button variant="outline" onClick={handleEditRecipe} disabled={!recipe}>
              Edytuj przepis
            </Button>
            <Button variant="destructive" onClick={handleRemoveFromCalendar} disabled={!assignmentId}>
              Usuń z kalendarza
            </Button>
            <Button onClick={onClose}>Zamknij</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }
);

RecipePreviewModal.displayName = "RecipePreviewModal";

export default RecipePreviewModal;



================================================
FILE: src/components/SearchBar.tsx
================================================
/**
 * Search Bar Component
 * Input field for searching with icon
 */
import { memo } from "react";
import { Input } from "@/components/ui/input";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
}

/**
 * Search Bar Component
 * Debounced search input with search icon
 */
export const SearchBar = memo<SearchBarProps>(({ value, onChange, placeholder = "Szukaj...", className = "" }) => {
  return (
    <div className={`relative ${className}`}>
      <svg
        className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400 pointer-events-none"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        aria-hidden="true"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
        />
      </svg>
      <Input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="pl-10"
        aria-label="Wyszukaj przepis"
      />
    </div>
  );
});

SearchBar.displayName = "SearchBar";



================================================
FILE: src/components/ShoppingListGenerateView.tsx
================================================
import React from "react";
import ShoppingListWizard from "./wizard/ShoppingListWizard";

/**
 * Główny widok generowania listy zakupów
 * Renderuje 4-etapowy wizard
 */
export default function ShoppingListGenerateView() {
  return (
    <div className="shopping-list-generate-view">
      <div className="container mx-auto max-w-5xl p-4">
        <ShoppingListWizard />
      </div>
    </div>
  );
}



================================================
FILE: src/components/WeekNavigator.tsx
================================================
/**
 * Week Navigator Component
 * Navigation between weeks with date range display
 */
import { memo } from "react";
import { Button } from "@/components/ui/button";
import { useWeekNavigation } from "@/components/hooks/useWeekNavigation";
import type { WeekChangeHandler } from "@/types";

interface WeekNavigatorProps {
  weekStartDate: string; // YYYY-MM-DD
  onWeekChange: WeekChangeHandler;
  dateRange: string; // "20-26 stycznia 2025"
}

/**
 * Week Navigator Component
 * Displays week navigation controls and date range
 */
export const WeekNavigator = memo<WeekNavigatorProps>(({ weekStartDate, onWeekChange, dateRange }) => {
  const { goToPreviousWeek, goToNextWeek, goToCurrentWeek } = useWeekNavigation(weekStartDate, onWeekChange);

  return (
    <nav className="sticky top-0 z-10 bg-white border-b shadow-sm" aria-label="Nawigacja tygodniowa">
      <div className="container mx-auto px-4 py-4">
        <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
          {/* Previous Week Button */}
          <Button
            variant="outline"
            onClick={goToPreviousWeek}
            className="w-full sm:w-auto"
            aria-label="Poprzedni tydzień"
          >
            <span className="mr-2">←</span>
            Poprzedni tydzień
          </Button>

          {/* Date Range Display */}
          <div className="flex flex-col items-center">
            <span className="text-lg font-semibold text-gray-900" aria-live="polite">
              {dateRange}
            </span>
            <Button
              variant="ghost"
              onClick={goToCurrentWeek}
              className="text-sm text-blue-600 hover:text-blue-800 mt-1"
              aria-label="Wróć do bieżącego tygodnia"
            >
              Bieżący tydzień
            </Button>
          </div>

          {/* Next Week Button */}
          <Button variant="outline" onClick={goToNextWeek} className="w-full sm:w-auto" aria-label="Następny tydzień">
            Następny tydzień
            <span className="ml-2">→</span>
          </Button>
        </div>
      </div>
    </nav>
  );
});

WeekNavigator.displayName = "WeekNavigator";



================================================
FILE: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w ShopMate Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
FILE: src/components/auth/LoginView.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { loginSchema } from "@/lib/validation/auth.schema";
import { toast } from "sonner";

interface LoginViewProps {
  redirectUrl?: string;
}

interface LoginFormData {
  email: string;
  password: string;
}

export default function LoginView({ redirectUrl = "/dashboard" }: LoginViewProps) {
  const [formData, setFormData] = useState<LoginFormData>({ email: "", password: "" });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrors({});

    // Client-side validation
    const validation = loginSchema.safeParse(formData);
    if (!validation.success) {
      const fieldErrors: Record<string, string> = {};
      validation.error.errors.forEach((error) => {
        if (error.path[0]) {
          fieldErrors[error.path[0] as string] = error.message;
        }
      });
      setErrors(fieldErrors);
      return;
    }

    setIsLoading(true);

    try {
      // Call server-side login API endpoint (answer 2.B - server-side auth)
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: validation.data.email,
          password: validation.data.password,
        }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        // Server returned error
        const errorMessage = data.error || "Nieprawidłowy email lub hasło";
        toast.error(errorMessage);
        setIsLoading(false);
        return;
      }

      // Success - cookies are set by server
      // Hybrid redirect (answer 3.C): API returns success, client does redirect
      toast.success("Zostałeś pomyślnie zalogowany");

      // Redirect to original URL or dashboard
      window.location.href = redirectUrl;
    } catch (error) {
      console.error("Login error:", error);
      toast.error("Brak połączenia. Sprawdź internet i spróbuj ponownie.");
      setIsLoading(false);
    }
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Zaloguj się</h2>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Email field */}
        <div>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            placeholder="twoj@email.pl"
            aria-describedby={errors.email ? "email-error" : undefined}
            aria-invalid={!!errors.email}
            disabled={isLoading}
          />
          {errors.email && (
            <p id="email-error" className="text-sm text-red-600 mt-1">
              {errors.email}
            </p>
          )}
        </div>

        {/* Password field */}
        <div>
          <Label htmlFor="password">Hasło</Label>
          <Input
            id="password"
            type="password"
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            aria-describedby={errors.password ? "password-error" : undefined}
            aria-invalid={!!errors.password}
            disabled={isLoading}
          />
          {errors.password && (
            <p id="password-error" className="text-sm text-red-600 mt-1">
              {errors.password}
            </p>
          )}
        </div>

        {/* Submit button */}
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? "Logowanie..." : "Zaloguj się"}
        </Button>
      </form>

      {/* Links */}
      <div className="space-y-2 mt-4">
        <p className="text-center text-sm">
          <a href="/reset-password" className="text-primary hover:underline">
            Nie pamiętam hasła
          </a>
        </p>
        <p className="text-center text-sm text-gray-600">
          Nie masz konta?{" "}
          <a href="/register" className="text-primary hover:underline">
            Zarejestruj się
          </a>
        </p>
      </div>
    </div>
  );
}



================================================
FILE: src/components/auth/RegisterView.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { registerSchema } from "@/lib/validation/auth.schema";
import { toast } from "sonner";

interface RegisterFormData {
  email: string;
  password: string;
  confirmPassword: string;
}

export default function RegisterView() {
  const [formData, setFormData] = useState<RegisterFormData>({
    email: "",
    password: "",
    confirmPassword: "",
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrors({});

    // Client-side validation
    const validation = registerSchema.safeParse(formData);
    if (!validation.success) {
      const fieldErrors: Record<string, string> = {};
      validation.error.errors.forEach((error) => {
        if (error.path[0]) {
          fieldErrors[error.path[0] as string] = error.message;
        }
      });
      setErrors(fieldErrors);
      return;
    }

    setIsLoading(true);

    try {
      // TODO: Implement Supabase Auth call when backend is ready
      // For now, just show a placeholder message
      toast.info("Funkcja rejestracji zostanie wkrótce zaimplementowana");
      console.log("Register data:", validation.data);
    } catch (error) {
      console.error("Register error:", error);
      toast.error("Wystąpił błąd podczas rejestracji");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Utwórz konto</h2>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Email field */}
        <div>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            placeholder="twoj@email.pl"
            aria-describedby={errors.email ? "email-error" : undefined}
            aria-invalid={!!errors.email}
            disabled={isLoading}
          />
          {errors.email && (
            <p id="email-error" className="text-sm text-red-600 mt-1">
              {errors.email}
            </p>
          )}
        </div>

        {/* Password field */}
        <div>
          <Label htmlFor="password">Hasło</Label>
          <Input
            id="password"
            type="password"
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            aria-describedby={errors.password ? "password-error" : undefined}
            aria-invalid={!!errors.password}
            disabled={isLoading}
          />
          {errors.password && (
            <p id="password-error" className="text-sm text-red-600 mt-1">
              {errors.password}
            </p>
          )}
        </div>

        {/* Confirm password field */}
        <div>
          <Label htmlFor="confirmPassword">Powtórz hasło</Label>
          <Input
            id="confirmPassword"
            type="password"
            value={formData.confirmPassword}
            onChange={(e) => setFormData({ ...formData, confirmPassword: e.target.value })}
            aria-describedby={errors.confirmPassword ? "confirm-password-error" : undefined}
            aria-invalid={!!errors.confirmPassword}
            disabled={isLoading}
          />
          {errors.confirmPassword && (
            <p id="confirm-password-error" className="text-sm text-red-600 mt-1">
              {errors.confirmPassword}
            </p>
          )}
        </div>

        {/* Submit button */}
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? "Tworzę konto..." : "Zarejestruj się"}
        </Button>
      </form>

      {/* Link to login */}
      <p className="text-center text-sm text-gray-600 mt-4">
        Masz już konto?{" "}
        <a href="/login" className="text-primary hover:underline">
          Zaloguj się
        </a>
      </p>
    </div>
  );
}



================================================
FILE: src/components/auth/ResetPasswordView.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { resetPasswordRequestSchema, updatePasswordSchema } from "@/lib/validation/auth.schema";
import { toast } from "sonner";

interface ResetPasswordViewProps {
  isResetCallback: boolean;
}

export default function ResetPasswordView({ isResetCallback }: ResetPasswordViewProps) {
  const [email, setEmail] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [emailSent, setEmailSent] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Tryb 1: Request password reset
  const handleRequestReset = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrors({});

    const validation = resetPasswordRequestSchema.safeParse({ email });
    if (!validation.success) {
      const fieldErrors: Record<string, string> = {};
      validation.error.errors.forEach((error) => {
        if (error.path[0]) {
          fieldErrors[error.path[0] as string] = error.message;
        }
      });
      setErrors(fieldErrors);
      return;
    }

    setIsLoading(true);

    try {
      // Call server-side reset password API endpoint
      const response = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: validation.data.email,
        }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        // Server returned error
        const errorMessage = data.error || "Nie udało się wysłać emaila. Sprawdź adres email.";
        toast.error(errorMessage);
        setIsLoading(false);
        return;
      }

      // Success - email sent (or silently ignored if email doesn't exist)
      toast.success(data.message || "Link do resetowania hasła został wysłany na email");
      setEmailSent(true);
    } catch (error) {
      console.error("Reset password error:", error);
      toast.error("Brak połączenia. Sprawdź internet i spróbuj ponownie.");
    } finally {
      setIsLoading(false);
    }
  };

  // Tryb 2: Update password
  const handleUpdatePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrors({});

    const validation = updatePasswordSchema.safeParse({ newPassword, confirmPassword });
    if (!validation.success) {
      const fieldErrors: Record<string, string> = {};
      validation.error.errors.forEach((error) => {
        if (error.path[0]) {
          fieldErrors[error.path[0] as string] = error.message;
        }
      });
      setErrors(fieldErrors);
      return;
    }

    setIsLoading(true);

    try {
      // Call server-side update password API endpoint
      const response = await fetch("/api/auth/update-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          newPassword: validation.data.newPassword,
          confirmPassword: validation.data.confirmPassword,
        }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        // Server returned error
        const errorMessage = data.error || "Nie udało się zmienić hasła";
        toast.error(errorMessage);
        setIsLoading(false);
        return;
      }

      // Success - password updated
      toast.success(data.message || "Hasło zostało zmienione");

      // Redirect to login page
      setTimeout(() => {
        window.location.href = "/login";
      }, 1500);
    } catch (error) {
      console.error("Update password error:", error);
      toast.error("Brak połączenia. Sprawdź internet i spróbuj ponownie.");
      setIsLoading(false);
    }
  };

  // Render based on mode
  if (isResetCallback) {
    return (
      <div>
        <h2 className="text-2xl font-bold mb-6">Ustaw nowe hasło</h2>
        <form onSubmit={handleUpdatePassword} className="space-y-4">
          {/* New password field */}
          <div>
            <Label htmlFor="newPassword">Nowe hasło</Label>
            <Input
              id="newPassword"
              type="password"
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              aria-describedby={errors.newPassword ? "new-password-error" : undefined}
              aria-invalid={!!errors.newPassword}
              disabled={isLoading}
            />
            {errors.newPassword && (
              <p id="new-password-error" className="text-sm text-red-600 mt-1">
                {errors.newPassword}
              </p>
            )}
          </div>

          {/* Confirm password field */}
          <div>
            <Label htmlFor="confirmPassword">Powtórz nowe hasło</Label>
            <Input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              aria-describedby={errors.confirmPassword ? "confirm-password-error" : undefined}
              aria-invalid={!!errors.confirmPassword}
              disabled={isLoading}
            />
            {errors.confirmPassword && (
              <p id="confirm-password-error" className="text-sm text-red-600 mt-1">
                {errors.confirmPassword}
              </p>
            )}
          </div>

          {/* Submit button */}
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? "Zmieniam hasło..." : "Zmień hasło"}
          </Button>
        </form>
      </div>
    );
  }

  if (emailSent) {
    return (
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-4">Sprawdź swoją skrzynkę email</h2>
        <p className="text-gray-600">
          Wysłaliśmy link do resetowania hasła na adres <strong>{email}</strong>
        </p>
        <p className="text-sm text-gray-500 mt-4">
          Jeśli email nie dotarł, sprawdź folder spam lub{" "}
          <button onClick={() => setEmailSent(false)} className="text-primary hover:underline">
            spróbuj ponownie
          </button>
        </p>
      </div>
    );
  }

  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Resetuj hasło</h2>
      <p className="text-gray-600 mb-4">Podaj swój adres email, a wyślemy Ci link do zresetowania hasła.</p>
      <form onSubmit={handleRequestReset} className="space-y-4">
        {/* Email field */}
        <div>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="twoj@email.pl"
            aria-describedby={errors.email ? "email-error" : undefined}
            aria-invalid={!!errors.email}
            disabled={isLoading}
          />
          {errors.email && (
            <p id="email-error" className="text-sm text-red-600 mt-1">
              {errors.email}
            </p>
          )}
        </div>

        {/* Submit button */}
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? "Wysyłam..." : "Wyślij link resetujący"}
        </Button>
      </form>

      {/* Link back to login */}
      <p className="text-center text-sm text-gray-600 mt-4">
        Pamiętasz hasło?{" "}
        <a href="/login" className="text-primary hover:underline">
          Zaloguj się
        </a>
      </p>
    </div>
  );
}



================================================
FILE: src/components/dashboard/ActionButton.tsx
================================================
/**
 * ActionButton - Przycisk CTA z ikoną, etykietą główną i opisem
 * Używany w QuickActionsSection
 */

import { cn } from "@/lib/utils";

interface ActionButtonProps {
  icon: React.ReactNode;
  label: string;
  description: string;
  href: string;
  variant: "primary" | "secondary";
}

export function ActionButton({ icon, label, description, href, variant }: ActionButtonProps) {
  return (
    <a
      href={href}
      className={cn(
        "action-button group flex items-center gap-4 p-5 rounded-lg border transition-all duration-200",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2",
        {
          "bg-primary-600 hover:bg-primary-700 border-primary-600 hover:border-primary-700 text-white shadow-md hover:shadow-lg":
            variant === "primary",
          "bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 border-gray-200 dark:border-gray-700 hover:border-primary-500 shadow-sm hover:shadow-md":
            variant === "secondary",
        }
      )}
    >
      <div
        className={cn("action-button-icon flex-shrink-0 group-hover:scale-110 transition-transform", {
          "text-white": variant === "primary",
          "text-primary-600 dark:text-primary-400": variant === "secondary",
        })}
      >
        {icon}
      </div>
      <div className="action-button-content flex-1 min-w-0">
        <span
          className={cn("action-button-label block font-semibold text-base mb-1", {
            "text-white": variant === "primary",
            "text-gray-900 dark:text-white": variant === "secondary",
          })}
        >
          {label}
        </span>
        <span
          className={cn("action-button-description block text-sm", {
            "text-primary-100": variant === "primary",
            "text-gray-600 dark:text-gray-400": variant === "secondary",
          })}
        >
          {description}
        </span>
      </div>
    </a>
  );
}



================================================
FILE: src/components/dashboard/DashboardHeader.tsx
================================================
/**
 * DashboardHeader - Nagłówek dashboardu
 * Wyświetla tytuł strony
 */

export function DashboardHeader() {
  return (
    <header className="dashboard-header mb-8">
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Dashboard</h1>
    </header>
  );
}



================================================
FILE: src/components/dashboard/DashboardSkeleton.tsx
================================================
/**
 * DashboardSkeleton - Skeleton loader dla dashboardu
 * Wyświetla szkielety wszystkich sekcji podczas ładowania danych
 */

export function DashboardSkeleton() {
  return (
    <div className="dashboard-skeleton">
      {/* Header Skeleton */}
      <div className="dashboard-header-skeleton mb-8">
        <div className="h-8 w-48 bg-gray-200 dark:bg-gray-700 rounded animate-pulse" />
      </div>

      {/* Stats Skeleton */}
      <div className="stats-skeleton mb-8">
        <div className="stats-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div
              key={`stat-${i}`}
              className="stat-card-skeleton h-28 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse"
            />
          ))}
        </div>
      </div>

      {/* Quick Actions Skeleton */}
      <div className="quick-actions-skeleton mb-8">
        <div className="quick-actions-grid grid grid-cols-1 md:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div
              key={`action-${i}`}
              className="action-button-skeleton h-24 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse"
            />
          ))}
        </div>
      </div>

      {/* Content Grid */}
      <div className="dashboard-content-skeleton grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Recent Recipes Skeleton */}
        <div className="recipes-skeleton">
          <div className="section-header-skeleton mb-4 flex items-center justify-between">
            <div className="h-6 w-40 bg-gray-200 dark:bg-gray-700 rounded animate-pulse" />
            <div className="h-4 w-32 bg-gray-200 dark:bg-gray-700 rounded animate-pulse" />
          </div>
          <div className="recipes-grid space-y-4">
            {[1, 2, 3].map((i) => (
              <div
                key={`recipe-${i}`}
                className="recipe-card-skeleton h-28 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </div>

        {/* Upcoming Meals Skeleton */}
        <div className="meals-skeleton">
          <div className="section-header-skeleton mb-4 flex items-center justify-between">
            <div className="h-6 w-48 bg-gray-200 dark:bg-gray-700 rounded animate-pulse" />
            <div className="h-4 w-32 bg-gray-200 dark:bg-gray-700 rounded animate-pulse" />
          </div>
          <div className="meals-timeline space-y-4">
            {[1, 2, 3].map((i) => (
              <div
                key={`meal-${i}`}
                className="meal-item-skeleton h-20 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/dashboard/DashboardView.tsx
================================================
/**
 * DashboardView - Główny kontener widoku Dashboard
 * Zarządza stanem całego dashboardu i renderuje odpowiednie komponenty
 */

import { useQueryClient } from "@tanstack/react-query";
import { useDashboard } from "@/components/hooks/useDashboard";
import { DashboardHeader } from "./DashboardHeader";
import { DashboardSkeleton } from "./DashboardSkeleton";
import { EmptyState } from "./EmptyState";
import { ErrorMessage } from "./ErrorMessage";
import { StatsSection } from "./StatsSection";
import { QuickActionsSection } from "./QuickActionsSection";
import { RecentRecipesSection } from "./RecentRecipesSection";
import { UpcomingMealsSection } from "./UpcomingMealsSection";

export function DashboardView() {
  const queryClient = useQueryClient();
  const { stats, recentRecipes, upcomingMeals, isNewUser, isLoading, error } = useDashboard();

  // Loading state - show skeleton
  if (isLoading) {
    return (
      <div className="dashboard-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <DashboardSkeleton />
      </div>
    );
  }

  // Error state - show error message
  if (error) {
    return (
      <div className="dashboard-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <ErrorMessage
          title="Nie udało się załadować dashboardu"
          message="Sprawdź połączenie z internetem i spróbuj ponownie."
          error={error}
          onRetry={() => {
            queryClient.invalidateQueries({ queryKey: ["recipes"] });
            queryClient.invalidateQueries({ queryKey: ["shopping-lists"] });
            queryClient.invalidateQueries({ queryKey: ["meal-plan"] });
          }}
        />
      </div>
    );
  }

  // Empty state - new user (0 recipes)
  if (isNewUser) {
    return (
      <div className="dashboard-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <DashboardHeader />
        <EmptyState />
      </div>
    );
  }

  // Normal dashboard view
  return (
    <div className="dashboard-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <DashboardHeader />

      {/* Stats Section */}
      <StatsSection stats={stats} />

      {/* Quick Actions Section */}
      <QuickActionsSection />

      {/* Content Grid - Recent Recipes + Upcoming Meals */}
      <div className="dashboard-content grid grid-cols-1 lg:grid-cols-2 gap-8">
        <RecentRecipesSection recipes={recentRecipes} />
        <UpcomingMealsSection meals={upcomingMeals} />
      </div>
    </div>
  );
}



================================================
FILE: src/components/dashboard/EmptyState.tsx
================================================
/**
 * EmptyState - Widok dla nowych użytkowników (0 przepisów)
 * Wyświetla komunikat powitalny, CTA i feature highlights
 */

import { ChefHat, Calendar, ShoppingCart, Sparkles } from "lucide-react";
import { Button } from "@/components/ui/button";

export function EmptyState() {
  return (
    <div className="empty-state max-w-3xl mx-auto py-12 px-4">
      {/* Ilustracja */}
      <div className="empty-state-illustration flex justify-center mb-8">
        <div className="w-32 h-32 bg-primary-100 dark:bg-primary-900/20 rounded-full flex items-center justify-center">
          <ChefHat className="w-16 h-16 text-primary-600 dark:text-primary-400" />
        </div>
      </div>

      {/* Treść */}
      <div className="empty-state-content text-center mb-10">
        <h2 className="text-3xl font-bold text-gray-900 dark:text-white mb-4">Witaj w ShopMate!</h2>
        <p className="text-lg text-gray-600 dark:text-gray-400 mb-6">Zacznij od dodania pierwszego przepisu</p>

        {/* CTA Button */}
        <a href="/recipes/new">
          <Button size="lg" className="empty-state-cta text-base px-8 py-6 h-auto">
            Dodaj pierwszy przepis
          </Button>
        </a>
        <p className="text-sm text-gray-500 dark:text-gray-400 mt-3">Będziesz mógł przypisać go do kalendarza</p>
      </div>

      {/* Feature Highlights */}
      <div className="empty-state-features grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="feature-highlight text-center p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-center mb-4">
            <div className="w-12 h-12 bg-primary-100 dark:bg-primary-900/20 rounded-full flex items-center justify-center">
              <Calendar className="w-6 h-6 text-primary-600 dark:text-primary-400" />
            </div>
          </div>
          <p className="text-sm font-medium text-gray-700 dark:text-gray-300">Planuj posiłki na cały tydzień</p>
        </div>

        <div className="feature-highlight text-center p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-center mb-4">
            <div className="w-12 h-12 bg-primary-100 dark:bg-primary-900/20 rounded-full flex items-center justify-center">
              <ShoppingCart className="w-6 h-6 text-primary-600 dark:text-primary-400" />
            </div>
          </div>
          <p className="text-sm font-medium text-gray-700 dark:text-gray-300">Generuj listy zakupów automatycznie</p>
        </div>

        <div className="feature-highlight text-center p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-center mb-4">
            <div className="w-12 h-12 bg-primary-100 dark:bg-primary-900/20 rounded-full flex items-center justify-center">
              <Sparkles className="w-6 h-6 text-primary-600 dark:text-primary-400" />
            </div>
          </div>
          <p className="text-sm font-medium text-gray-700 dark:text-gray-300">AI kategoryzuje składniki za Ciebie</p>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/dashboard/ErrorMessage.tsx
================================================
/**
 * ErrorMessage - Komponent wyświetlający błędy
 * Pokazuje komunikat błędu z opcją ponowienia próby
 */

import { AlertCircle, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorMessageProps {
  title?: string;
  message?: string;
  error?: Error | null;
  onRetry?: () => void;
}

export function ErrorMessage({
  title = "Wystąpił błąd",
  message = "Nie udało się załadować danych. Spróbuj ponownie.",
  error,
  onRetry,
}: ErrorMessageProps) {
  return (
    <div className="error-message max-w-2xl mx-auto py-12 px-4">
      <div className="bg-red-50 dark:bg-red-900/10 border border-red-200 dark:border-red-800 rounded-lg p-8 text-center">
        {/* Icon */}
        <div className="flex justify-center mb-4">
          <div className="w-16 h-16 bg-red-100 dark:bg-red-900/20 rounded-full flex items-center justify-center">
            <AlertCircle className="w-8 h-8 text-red-600 dark:text-red-400" />
          </div>
        </div>

        {/* Title */}
        <h3 className="text-xl font-semibold text-red-900 dark:text-red-100 mb-2">{title}</h3>

        {/* Message */}
        <p className="text-red-700 dark:text-red-300 mb-6">{message}</p>

        {/* Error details (dev mode) */}
        {error && import.meta.env.DEV && (
          <details className="mb-6 text-left">
            <summary className="text-sm text-red-600 dark:text-red-400 cursor-pointer mb-2">Szczegóły błędu</summary>
            <pre className="text-xs bg-red-100 dark:bg-red-900/20 p-3 rounded overflow-auto text-red-800 dark:text-red-200">
              {error.message}
              {error.stack && `\n\n${error.stack}`}
            </pre>
          </details>
        )}

        {/* Retry button */}
        {onRetry && (
          <Button onClick={onRetry} variant="outline" size="lg">
            <RefreshCw className="w-4 h-4 mr-2" />
            Spróbuj ponownie
          </Button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/dashboard/MealItem.tsx
================================================
/**
 * MealItem - Pojedynczy element timeline posiłku
 * Wyświetla dzień ("Dzisiaj"/"Jutro"), typ posiłku i nazwę przepisu
 */

import { cn } from "@/lib/utils";
import type { UpcomingMealViewModel } from "@/types";

interface MealItemProps {
  meal: UpcomingMealViewModel;
}

export function MealItem({ meal }: MealItemProps) {
  return (
    <div className="meal-item relative flex gap-4 pb-6 last:pb-0">
      {/* Timeline indicator */}
      <div className="meal-item-indicator relative flex flex-col items-center">
        <div className="w-3 h-3 rounded-full bg-primary-500 dark:bg-primary-400 ring-4 ring-white dark:ring-gray-900 z-10" />
        <div className="absolute top-3 bottom-0 w-px bg-gray-200 dark:bg-gray-700 last:hidden" />
      </div>

      {/* Content */}
      <div className="meal-item-content flex-1 pt-0.5">
        <div className="meal-item-header flex items-center gap-2 mb-1">
          <span className="meal-item-day text-sm font-semibold text-primary-600 dark:text-primary-400">{meal.day}</span>
          <span className="meal-item-date text-sm text-gray-500 dark:text-gray-400">{meal.date}</span>
        </div>
        <div className="meal-item-body">
          <span className="meal-item-type text-sm text-gray-600 dark:text-gray-300 block mb-1">
            {meal.mealTypeLabel}
          </span>
          <a
            href={`/recipes/${meal.recipeId}`}
            className={cn(
              "meal-item-recipe inline-block font-medium text-gray-900 dark:text-white",
              "hover:text-primary-600 dark:hover:text-primary-400 transition-colors",
              "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 rounded"
            )}
          >
            {meal.recipeName}
          </a>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/dashboard/QuickActionsSection.tsx
================================================
/**
 * QuickActionsSection - Sekcja z szybkimi akcjami (CTA)
 * Wyświetla 3 przyciski: Dodaj przepis, Zaplanuj tydzień, Generuj listę
 */

import { Plus, Calendar, ShoppingCart } from "lucide-react";
import { ActionButton } from "./ActionButton";

export function QuickActionsSection() {
  return (
    <section className="quick-actions-section mb-8" aria-label="Szybkie akcje">
      <div className="quick-actions-grid grid grid-cols-1 md:grid-cols-3 gap-4">
        <ActionButton
          icon={<Plus className="w-6 h-6" />}
          label="Dodaj przepis"
          description="Stwórz nowy przepis"
          href="/recipes/new"
          variant="primary"
        />
        <ActionButton
          icon={<Calendar className="w-6 h-6" />}
          label="Zaplanuj tydzień"
          description="Przypisz przepisy do kalendarza"
          href="/calendar"
          variant="secondary"
        />
        <ActionButton
          icon={<ShoppingCart className="w-6 h-6" />}
          label="Generuj listę"
          description="Stwórz listę zakupów"
          href="/shopping-lists/generate"
          variant="secondary"
        />
      </div>
    </section>
  );
}



================================================
FILE: src/components/dashboard/RecentRecipesSection.tsx
================================================
/**
 * RecentRecipesSection - Sekcja z ostatnimi przepisami
 * Wyświetla 3 ostatnio dodane przepisy
 */

import { ArrowRight } from "lucide-react";
import { RecipeCard } from "./RecipeCard";
import type { RecipeListItemDto } from "@/types";

interface RecentRecipesSectionProps {
  recipes: RecipeListItemDto[];
  isLoading?: boolean;
}

export function RecentRecipesSection({ recipes, isLoading }: RecentRecipesSectionProps) {
  if (isLoading) {
    return (
      <section className="recent-recipes-section mb-8">
        <div className="section-header flex items-center justify-between mb-4">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">Ostatnie przepisy</h2>
        </div>
        <div className="recipes-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="recipe-card-skeleton h-32 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse" />
          ))}
        </div>
      </section>
    );
  }

  return (
    <section className="recent-recipes-section mb-8">
      <div className="section-header flex items-center justify-between mb-4">
        <h2 className="text-xl font-bold text-gray-900 dark:text-white">Ostatnie przepisy</h2>
        <a
          href="/recipes"
          className="view-all-link inline-flex items-center gap-1 text-sm font-medium text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-colors"
        >
          Zobacz wszystkie
          <ArrowRight className="w-4 h-4" />
        </a>
      </div>

      {recipes.length === 0 ? (
        <div className="empty-message p-8 text-center bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <p className="text-gray-600 dark:text-gray-400 mb-4">Nie masz jeszcze przepisów</p>
          <a
            href="/recipes/new"
            className="inline-flex items-center gap-2 px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white font-medium rounded-lg transition-colors"
          >
            <span>Dodaj pierwszy przepis</span>
          </a>
        </div>
      ) : (
        <div className="recipes-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {recipes.map((recipe) => (
            <RecipeCard key={recipe.id} recipe={recipe} />
          ))}
        </div>
      )}
    </section>
  );
}



================================================
FILE: src/components/dashboard/RecipeCard.tsx
================================================
/**
 * RecipeCard - Karta przepisu
 * Wyświetla nazwę przepisu (skrócona do 50 znaków), liczbę składników i datę dodania
 * Karta jest kliklalna i prowadzi do szczegółów przepisu
 */

import { cn } from "@/lib/utils";
import { truncate } from "@/lib/utils/text";
import { formatRelativeTime } from "@/lib/utils/date";
import { Badge } from "@/components/ui/badge";
import type { RecipeListItemDto } from "@/types";

interface RecipeCardProps {
  recipe: RecipeListItemDto;
}

export function RecipeCard({ recipe }: RecipeCardProps) {
  // Truncate name do 50 znaków
  const truncatedName = truncate(recipe.name, 50);

  // Format relative time
  const relativeTime = formatRelativeTime(recipe.created_at);

  return (
    <a
      href={`/recipes/${recipe.id}`}
      className={cn(
        "recipe-card group block",
        "p-5 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700",
        "shadow-sm hover:shadow-md transition-all duration-200",
        "hover:border-primary-500 dark:hover:border-primary-400",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2"
      )}
    >
      <article>
        <h3
          className="recipe-card-name text-lg font-semibold text-gray-900 dark:text-white mb-3 group-hover:text-primary-600 dark:group-hover:text-primary-400 transition-colors"
          title={recipe.name}
        >
          {truncatedName}
        </h3>
        <div className="recipe-card-meta flex items-center justify-between gap-2">
          <Badge variant="secondary" className="text-xs">
            {recipe.ingredients_count} składników
          </Badge>
          <time dateTime={recipe.created_at} className="recipe-card-date text-sm text-gray-500 dark:text-gray-400">
            {relativeTime}
          </time>
        </div>
      </article>
    </a>
  );
}



================================================
FILE: src/components/dashboard/StatCard.tsx
================================================
/**
 * StatCard - Pojedyncza karta statystyki
 * Wyświetla ikonę, etykietę i wartość liczbową
 * Karta jest kliklalna i prowadzi do odpowiedniej sekcji aplikacji
 */

import { cn } from "@/lib/utils";

interface StatCardProps {
  icon: React.ReactNode;
  label: string;
  value: number;
  href: string;
}

export function StatCard({ icon, label, value, href }: StatCardProps) {
  // Walidacja: zawsze wyświetlamy liczbę nieujemną
  const displayValue = typeof value === "number" && value >= 0 ? value : 0;

  return (
    <a
      href={href}
      className={cn(
        "stat-card group",
        "flex items-center gap-4 p-6",
        "bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700",
        "shadow-sm hover:shadow-md transition-all duration-200",
        "hover:border-primary-500 dark:hover:border-primary-400",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2"
      )}
      aria-label={`${label}: ${displayValue}`}
    >
      <div className="stat-card-icon flex-shrink-0 text-primary-600 dark:text-primary-400 group-hover:scale-110 transition-transform">
        {icon}
      </div>
      <div className="stat-card-content flex-1 min-w-0">
        <p className="stat-card-label text-sm font-medium text-gray-600 dark:text-gray-400 mb-1">{label}</p>
        <p className="stat-card-value text-3xl font-bold text-gray-900 dark:text-white">{displayValue}</p>
      </div>
    </a>
  );
}



================================================
FILE: src/components/dashboard/StatsSection.tsx
================================================
/**
 * StatsSection - Sekcja ze statystykami
 * Wyświetla 3 karty: liczba przepisów, posiłków w kalendarzu, list zakupów
 */

import { ChefHat, Calendar, ShoppingCart } from "lucide-react";
import { StatCard } from "./StatCard";
import type { DashboardStats } from "@/types";

interface StatsSectionProps {
  stats: DashboardStats;
  isLoading?: boolean;
}

export function StatsSection({ stats, isLoading }: StatsSectionProps) {
  if (isLoading) {
    // Skeleton podczas ładowania
    return (
      <section className="stats-section mb-8" aria-label="Statystyki">
        <div className="stats-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="stat-card-skeleton h-28 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse" />
          ))}
        </div>
      </section>
    );
  }

  return (
    <section className="stats-section mb-8" aria-label="Statystyki">
      <div className="stats-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <StatCard icon={<ChefHat className="w-8 h-8" />} label="Przepisy" value={stats.recipesCount} href="/recipes" />
        <StatCard
          icon={<Calendar className="w-8 h-8" />}
          label="Zaplanowane posiłki"
          value={stats.mealPlansCount}
          href="/calendar"
        />
        <StatCard
          icon={<ShoppingCart className="w-8 h-8" />}
          label="Listy zakupów"
          value={stats.shoppingListsCount}
          href="/shopping-lists"
        />
      </div>
    </section>
  );
}



================================================
FILE: src/components/dashboard/UpcomingMealsSection.tsx
================================================
/**
 * UpcomingMealsSection - Sekcja z nadchodzącymi posiłkami
 * Wyświetla posiłki zaplanowane na dziś i jutro w formie timeline
 */

import { ArrowRight } from "lucide-react";
import { MealItem } from "./MealItem";
import type { UpcomingMealViewModel } from "@/types";

interface UpcomingMealsSectionProps {
  meals: UpcomingMealViewModel[];
  isLoading?: boolean;
}

export function UpcomingMealsSection({ meals, isLoading }: UpcomingMealsSectionProps) {
  if (isLoading) {
    return (
      <section className="upcoming-meals-section mb-8">
        <div className="section-header flex items-center justify-between mb-4">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">Nadchodzące posiłki</h2>
        </div>
        <div className="meals-timeline space-y-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="meal-item-skeleton h-20 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse" />
          ))}
        </div>
      </section>
    );
  }

  return (
    <section className="upcoming-meals-section mb-8">
      <div className="section-header flex items-center justify-between mb-4">
        <h2 className="text-xl font-bold text-gray-900 dark:text-white">Nadchodzące posiłki</h2>
        <a
          href="/calendar"
          className="view-calendar-link inline-flex items-center gap-1 text-sm font-medium text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-colors"
        >
          Zobacz kalendarz
          <ArrowRight className="w-4 h-4" />
        </a>
      </div>

      {meals.length === 0 ? (
        <div className="empty-message p-8 text-center bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <p className="text-gray-600 dark:text-gray-400 mb-4">Brak zaplanowanych posiłków</p>
          <a
            href="/calendar"
            className="inline-flex items-center gap-2 px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white font-medium rounded-lg transition-colors"
          >
            <span>Zaplanuj tydzień</span>
          </a>
        </div>
      ) : (
        <div className="meals-timeline bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
          {meals.map((meal, index) => (
            <MealItem key={`${meal.recipeId}-${meal.dayOfWeek}-${meal.mealType}`} meal={meal} />
          ))}
        </div>
      )}
    </section>
  );
}



================================================
FILE: src/components/hooks/useCalendar.ts
================================================
/**
 * Main calendar hook
 * Manages calendar state, meal plan data, and modal states
 */
import { useState, useCallback, useMemo, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import type {
  CreateMealPlanDto,
  MealPlanAssignmentDto,
  MealType,
  RecipePickerState,
  RecipePreviewState,
  WeekCalendarResponseDto,
} from "@/types";
import { fetchMealPlan, createMealPlanAssignment, deleteMealPlanAssignment } from "@/lib/api/meal-plan";
import { buildCalendarCells } from "@/lib/utils/calendar";
import { getCurrentWeekStart, formatDateRange, getWeekEndDate, isValidWeekDate } from "@/lib/utils/date";

/**
 * Main calendar hook
 * Manages all calendar state and operations
 *
 * @param initialWeekStart - Optional initial week start date from URL
 * @returns Calendar state and handlers
 */
export function useCalendar(initialWeekStart?: string) {
  // === State ===
  const [weekStartDate, setWeekStartDate] = useState<string>(
    initialWeekStart && isValidWeekDate(initialWeekStart) ? initialWeekStart : getCurrentWeekStart()
  );

  const [recipePickerState, setRecipePickerState] = useState<RecipePickerState>({
    isOpen: false,
    targetCell: null,
  });

  const [recipePreviewState, setRecipePreviewState] = useState<RecipePreviewState>({
    isOpen: false,
    recipeId: null,
    assignmentId: null,
  });

  // === TanStack Query ===
  const queryClient = useQueryClient();

  // Fetch meal plan for current week
  const {
    data: mealPlanData,
    isLoading,
    error,
    refetch,
  } = useQuery<WeekCalendarResponseDto>({
    queryKey: ["meal-plan", weekStartDate],
    queryFn: () => fetchMealPlan(weekStartDate),
    staleTime: 0, // Always fresh
    refetchOnWindowFocus: true,
  });

  // Mutation: Create assignment with optimistic update
  const createAssignmentMutation = useMutation({
    mutationFn: (dto: CreateMealPlanDto) => createMealPlanAssignment(dto),
    onMutate: async (newAssignment) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["meal-plan", weekStartDate] });

      // Snapshot the previous value
      const previousData = queryClient.getQueryData<WeekCalendarResponseDto>(["meal-plan", weekStartDate]);

      // Optimistically update to the new value
      queryClient.setQueryData<WeekCalendarResponseDto>(["meal-plan", weekStartDate], (old) => {
        if (!old) return old;
        return {
          ...old,
          assignments: [
            ...old.assignments,
            {
              id: "temp-" + Date.now(), // Temporary ID
              user_id: "temp",
              ...newAssignment,
              recipe_name: "Ładowanie...", // Will be replaced
              created_at: new Date().toISOString(),
            } as MealPlanAssignmentDto,
          ],
        };
      });

      return { previousData };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousData) {
        queryClient.setQueryData(["meal-plan", weekStartDate], context.previousData);
      }
      console.error("Failed to assign recipe:", err);
      alert("Nie udało się przypisać przepisu. Spróbuj ponownie.");
    },
    onSuccess: () => {
      console.log("Recipe assigned successfully");
    },
    onSettled: () => {
      // Always refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ["meal-plan", weekStartDate] });
    },
  });

  // Mutation: Delete assignment with optimistic update
  const deleteAssignmentMutation = useMutation({
    mutationFn: (assignmentId: string) => deleteMealPlanAssignment(assignmentId),
    onMutate: async (assignmentId) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["meal-plan", weekStartDate] });

      // Snapshot the previous value
      const previousData = queryClient.getQueryData<WeekCalendarResponseDto>(["meal-plan", weekStartDate]);

      // Optimistically remove from cache
      queryClient.setQueryData<WeekCalendarResponseDto>(["meal-plan", weekStartDate], (old) => {
        if (!old) return old;
        return {
          ...old,
          assignments: old.assignments.filter((a) => a.id !== assignmentId),
        };
      });

      return { previousData };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousData) {
        queryClient.setQueryData(["meal-plan", weekStartDate], context.previousData);
      }
      console.error("Failed to remove assignment:", err);
      alert("Nie udało się usunąć przypisania. Spróbuj ponownie.");
    },
    onSuccess: () => {
      console.log("Assignment removed successfully");
    },
    onSettled: () => {
      // Always refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ["meal-plan", weekStartDate] });
    },
  });

  // === Handlers ===

  /**
   * Handle week change
   * Updates state and URL
   */
  const handleWeekChange = useCallback((newWeekStart: string) => {
    setWeekStartDate(newWeekStart);
    // Update URL
    const url = new URL(window.location.href);
    url.searchParams.set("week", newWeekStart);
    window.history.pushState({}, "", url.toString());
  }, []);

  /**
   * Handle assign recipe action
   * Opens recipe picker modal
   */
  const handleAssignRecipe = useCallback(
    (dayOfWeek: number, mealType: MealType) => {
      const date = new Date(weekStartDate);
      date.setDate(date.getDate() + (dayOfWeek - 1));

      setRecipePickerState({
        isOpen: true,
        targetCell: {
          dayOfWeek,
          mealType,
          date,
        },
      });
    },
    [weekStartDate]
  );

  /**
   * Handle recipe selected from picker
   * Creates assignment and closes modal
   */
  const handleRecipeSelected = useCallback(
    async (recipeId: string) => {
      if (!recipePickerState.targetCell) return;

      const dto: CreateMealPlanDto = {
        recipe_id: recipeId,
        week_start_date: weekStartDate,
        day_of_week: recipePickerState.targetCell.dayOfWeek,
        meal_type: recipePickerState.targetCell.mealType,
      };

      await createAssignmentMutation.mutateAsync(dto);
      setRecipePickerState({ isOpen: false, targetCell: null });
    },
    [recipePickerState, weekStartDate, createAssignmentMutation]
  );

  /**
   * Handle remove assignment
   * Deletes assignment with optimistic update
   */
  const handleRemoveAssignment = useCallback(
    async (assignmentId: string) => {
      await deleteAssignmentMutation.mutateAsync(assignmentId);
    },
    [deleteAssignmentMutation]
  );

  /**
   * Handle preview recipe
   * Opens recipe preview modal
   */
  const handlePreviewRecipe = useCallback((recipeId: string, assignmentId: string) => {
    setRecipePreviewState({
      isOpen: true,
      recipeId,
      assignmentId,
    });
  }, []);

  // === Computed values ===

  const weekEndDate = useMemo(() => getWeekEndDate(weekStartDate), [weekStartDate]);

  const dateRange = useMemo(() => formatDateRange(weekStartDate, weekEndDate), [weekStartDate, weekEndDate]);

  const cells = useMemo(
    () => buildCalendarCells(weekStartDate, mealPlanData?.assignments || []),
    [weekStartDate, mealPlanData]
  );

  // === URL sync on mount ===
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const weekParam = params.get("week");

    if (weekParam && isValidWeekDate(weekParam) && weekParam !== weekStartDate) {
      setWeekStartDate(weekParam);
    }
  }, []);

  // === Browser back/forward handling ===
  useEffect(() => {
    const handlePopState = () => {
      const params = new URLSearchParams(window.location.search);
      const weekParam = params.get("week");

      if (weekParam && isValidWeekDate(weekParam)) {
        setWeekStartDate(weekParam);
      } else {
        setWeekStartDate(getCurrentWeekStart());
      }
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  return {
    // State
    weekStartDate,
    weekEndDate,
    dateRange,
    assignments: mealPlanData?.assignments || [],
    cells,
    isLoading,
    error,
    refetch,

    // Modal states
    recipePickerState,
    recipePreviewState,

    // Handlers
    handleWeekChange,
    handleAssignRecipe,
    handleRecipeSelected,
    handleRemoveAssignment,
    handlePreviewRecipe,

    // Modal controllers
    closeRecipePicker: () => setRecipePickerState({ isOpen: false, targetCell: null }),
    closeRecipePreview: () => setRecipePreviewState({ isOpen: false, recipeId: null, assignmentId: null }),

    // Mutation states
    isCreating: createAssignmentMutation.isPending,
    isDeleting: deleteAssignmentMutation.isPending,
  };
}



================================================
FILE: src/components/hooks/useDashboard.ts
================================================
/**
 * useDashboard - Custom hook zarządzający stanem dashboardu
 * Agreguje dane z wielu źródeł i transformuje je do postaci odpowiedniej dla UI
 */

import { useQuery } from "@tanstack/react-query";
import { useMemo } from "react";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
import { getCurrentWeekStart } from "@/lib/utils/date";
import type {
  DashboardData,
  DashboardStats,
  UpcomingMealViewModel,
  RecipeListItemDto,
  ShoppingListListItemDto,
  MealPlanAssignmentDto,
  WeekCalendarResponseDto,
  PaginatedResponse,
  MealType,
} from "@/types";
import { MEAL_TYPE_LABELS, MEAL_TYPE_ORDER } from "@/types";

export function useDashboard(): DashboardData {
  const currentWeekStart = getCurrentWeekStart();

  // Fetch 1: Statystyki przepisów (używamy pagination.total)
  const {
    data: recipesData,
    isLoading: recipesLoading,
    error: recipesError,
  } = useQuery({
    queryKey: ["recipes", "stats"],
    queryFn: async () => {
      const response = await fetch("/api/recipes?page=1&limit=1");
      if (!response.ok) {
        throw new Error("Failed to fetch recipes stats");
      }
      return response.json() as Promise<PaginatedResponse<RecipeListItemDto>>;
    },
    staleTime: 5 * 60 * 1000, // 5 minut
  });

  // Fetch 2: Statystyki list zakupów
  const {
    data: shoppingListsData,
    isLoading: shoppingListsLoading,
    error: shoppingListsError,
  } = useQuery({
    queryKey: ["shopping-lists", "stats"],
    queryFn: async () => {
      const response = await fetch("/api/shopping-lists?page=1&limit=1");
      if (!response.ok) {
        throw new Error("Failed to fetch shopping lists stats");
      }
      return response.json() as Promise<PaginatedResponse<ShoppingListListItemDto>>;
    },
    staleTime: 5 * 60 * 1000,
  });

  // Fetch 3: Kalendarz bieżącego tygodnia (dla statystyk i upcoming meals)
  const {
    data: mealPlanData,
    isLoading: mealPlanLoading,
    error: mealPlanError,
  } = useQuery({
    queryKey: ["meal-plan", currentWeekStart],
    queryFn: async () => {
      const response = await fetch(`/api/meal-plan?week_start_date=${currentWeekStart}`);
      if (!response.ok) {
        throw new Error("Failed to fetch meal plan");
      }
      return response.json() as Promise<WeekCalendarResponseDto>;
    },
    staleTime: 0, // Zawsze fresh
    refetchOnWindowFocus: true,
  });

  // Fetch 4: Ostatnie 3 przepisy
  const {
    data: recentRecipesData,
    isLoading: recentRecipesLoading,
    error: recentRecipesError,
  } = useQuery({
    queryKey: ["recipes", "recent"],
    queryFn: async () => {
      const response = await fetch("/api/recipes?page=1&limit=3&sort=created_desc");
      if (!response.ok) {
        throw new Error("Failed to fetch recent recipes");
      }
      return response.json() as Promise<PaginatedResponse<RecipeListItemDto>>;
    },
    staleTime: 2 * 60 * 1000, // 2 minuty
  });

  // Compute stats
  const stats: DashboardStats = {
    recipesCount: recipesData?.pagination.total ?? 0,
    mealPlansCount: mealPlanData?.assignments.length ?? 0,
    shoppingListsCount: shoppingListsData?.pagination.total ?? 0,
  };

  // Compute upcoming meals (dziś i jutro)
  const upcomingMeals: UpcomingMealViewModel[] = useMemo(() => {
    if (!mealPlanData?.assignments) {
      return [];
    }

    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayDayOfWeek = today.getDay() === 0 ? 7 : today.getDay(); // 1-7
    const tomorrowDayOfWeek = tomorrow.getDay() === 0 ? 7 : tomorrow.getDay();

    return mealPlanData.assignments
      .filter((assignment) => assignment.day_of_week === todayDayOfWeek || assignment.day_of_week === tomorrowDayOfWeek)
      .map((assignment) => {
        const isToday = assignment.day_of_week === todayDayOfWeek;
        const date = isToday ? today : tomorrow;

        return {
          day: isToday ? "Dzisiaj" : "Jutro",
          date: format(date, "d MMMM", { locale: pl }),
          isoDate: format(date, "yyyy-MM-dd"),
          dayOfWeek: assignment.day_of_week,
          mealType: assignment.meal_type,
          mealTypeLabel: MEAL_TYPE_LABELS[assignment.meal_type],
          recipeName: assignment.recipe_name,
          recipeId: assignment.recipe_id,
          sortOrder: (isToday ? 0 : 4) + MEAL_TYPE_ORDER[assignment.meal_type],
        } as UpcomingMealViewModel;
      })
      .sort((a, b) => a.sortOrder - b.sortOrder);
  }, [mealPlanData]);

  // Aggregate loading state
  const isLoading = recipesLoading || shoppingListsLoading || mealPlanLoading || recentRecipesLoading;

  // Aggregate errors (return first error found)
  const error = (recipesError || shoppingListsError || mealPlanError || recentRecipesError) as Error | null;

  return {
    stats,
    recentRecipes: recentRecipesData?.data ?? [],
    upcomingMeals,
    isNewUser: stats.recipesCount === 0,
    isLoading,
    error,
  };
}



================================================
FILE: src/components/hooks/useDebouncedValue.ts
================================================
/**
 * Custom hook for debouncing a value
 * Used for search input to reduce API calls
 */
import { useState, useEffect } from "react";

/**
 * Debounce a value by delaying its update
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds
 * @returns Debounced value
 *
 * @example
 * const [searchInput, setSearchInput] = useState('');
 * const debouncedSearch = useDebouncedValue(searchInput, 300);
 */
export function useDebouncedValue<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up timeout to update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up timeout if value changes or component unmounts
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}



================================================
FILE: src/components/hooks/useRecipeSearch.ts
================================================
/**
 * Recipe search hook
 * Handles recipe search with debounce and infinite scroll
 */
import { useState, useEffect, useMemo } from "react";
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchRecipes } from "@/lib/api/recipes";

/**
 * Recipe search hook
 * Provides debounced search with infinite scroll
 *
 * @returns Search state and handlers
 */
export function useRecipeSearch() {
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");

  // Debounce search query (300ms)
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery);
    }, 300);

    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Infinite query for recipes
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, error } = useInfiniteQuery({
    queryKey: ["recipes", debouncedQuery],
    queryFn: ({ pageParam = 1 }) =>
      fetchRecipes({
        search: debouncedQuery,
        page: pageParam,
        limit: 20,
      }),
    getNextPageParam: (lastPage) => {
      const { page, total_pages } = lastPage.pagination;
      return page < total_pages ? page + 1 : undefined;
    },
    initialPageParam: 1,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Flatten all pages into single array
  const recipes = useMemo(() => data?.pages.flatMap((page) => page.data) || [], [data]);

  return {
    searchQuery,
    setSearchQuery,
    recipes,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    error,
  };
}



================================================
FILE: src/components/hooks/useRecipesList.ts
================================================
/**
 * Custom hook for Recipes List view
 * Manages recipes list state, infinite scroll, search and sorting
 */
import { useState, useEffect, useCallback, useMemo } from "react";
import { useInfiniteQuery, useQueryClient } from "@tanstack/react-query";
import { useDebouncedValue } from "./useDebouncedValue";
import { fetchRecipes, fetchRecipe } from "@/lib/api/recipes";
import type { RecipeSortOption, RecipesPageResponse, RecipeListItemDto, PaginatedResponse } from "@/types";

const RECIPES_PER_PAGE = 20;
const SEARCH_DEBOUNCE_MS = 300;
const VALID_SORT_OPTIONS: RecipeSortOption[] = ["name_asc", "name_desc", "created_asc", "created_desc"];

/**
 * Parse and validate sort parameter from URL
 * @param sortParam - Sort parameter from URL
 * @returns Valid sort option or default
 */
function parseSort(sortParam: string | null): RecipeSortOption {
  if (sortParam && VALID_SORT_OPTIONS.includes(sortParam as RecipeSortOption)) {
    return sortParam as RecipeSortOption;
  }
  return "created_desc"; // Default
}

/**
 * Main hook for Recipes List view
 * Manages search, sort, infinite scroll and URL sync
 *
 * @returns Recipes list state and handlers
 */
export function useRecipesList() {
  const queryClient = useQueryClient();

  // === Parse URL params on mount ===
  const [initialParams] = useState(() => {
    const params = new URLSearchParams(window.location.search);
    return {
      search: params.get("search") || "",
      sort: parseSort(params.get("sort")),
    };
  });

  // === State ===
  const [searchInput, setSearchInput] = useState<string>(initialParams.search);
  const [sort, setSort] = useState<RecipeSortOption>(initialParams.sort);

  // Debounced search value
  const debouncedSearch = useDebouncedValue(searchInput, SEARCH_DEBOUNCE_MS);

  // === Sync debounced search with URL (shallow) ===
  useEffect(() => {
    const params = new URLSearchParams();

    if (debouncedSearch) {
      params.set("search", debouncedSearch);
    }
    if (sort !== "created_desc") {
      params.set("sort", sort);
    }

    const newUrl = params.toString() ? `/recipes?${params.toString()}` : "/recipes";

    // Shallow update (replaceState instead of pushState)
    window.history.replaceState({}, "", newUrl);
  }, [debouncedSearch, sort]);

  // === Infinite query for recipes ===
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, error, refetch } =
    useInfiniteQuery<RecipesPageResponse>({
      queryKey: ["recipes", "list", debouncedSearch, sort],
      queryFn: async ({ pageParam = 1 }) => {
        const result: PaginatedResponse<RecipeListItemDto> = await fetchRecipes({
          search: debouncedSearch || undefined,
          sort,
          page: pageParam as number,
          limit: RECIPES_PER_PAGE,
        });

        return {
          data: result.data,
          pagination: result.pagination,
          nextPage: result.pagination.page < result.pagination.total_pages ? result.pagination.page + 1 : undefined,
        };
      },
      getNextPageParam: (lastPage) => lastPage.nextPage,
      initialPageParam: 1,
      staleTime: 2 * 60 * 1000, // 2 minutes
      refetchOnWindowFocus: true,
    });

  // === Flatten pages to single list ===
  const recipes = useMemo(() => data?.pages.flatMap((page) => page.data) ?? [], [data]);

  // === Total count from first page ===
  const totalRecipes = data?.pages[0]?.pagination.total ?? 0;

  // === Handlers ===

  /**
   * Handle search input change
   * Updates local state (debounce happens automatically)
   */
  const handleSearchChange = useCallback((value: string) => {
    // Sanitize and trim
    const sanitized = value.trim().slice(0, 100);
    setSearchInput(sanitized);
  }, []);

  /**
   * Handle sort change
   * Updates state and triggers refetch
   */
  const handleSortChange = useCallback((value: RecipeSortOption) => {
    setSort(value);
  }, []);

  /**
   * Prefetch recipe details (for hover on RecipeCard)
   * Caches recipe data for instant navigation
   */
  const prefetchRecipe = useCallback(
    (recipeId: string) => {
      queryClient.prefetchQuery({
        queryKey: ["recipe", recipeId],
        queryFn: () => fetchRecipe(recipeId),
        staleTime: 10 * 60 * 1000, // 10 minutes
      });
    },
    [queryClient]
  );

  // === Browser back/forward handling ===
  useEffect(() => {
    const handlePopState = () => {
      const params = new URLSearchParams(window.location.search);
      const searchParam = params.get("search") || "";
      const sortParam = parseSort(params.get("sort"));

      setSearchInput(searchParam);
      setSort(sortParam);
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  return {
    // State
    search: searchInput,
    sort,
    recipes,
    totalRecipes,
    hasNextPage: hasNextPage ?? false,
    isLoading,
    isFetchingNextPage,
    error: error as Error | null,

    // Handlers
    handleSearchChange,
    handleSortChange,
    fetchNextPage,
    refetch,
    prefetchRecipe,
  };
}



================================================
FILE: src/components/hooks/useWeekNavigation.ts
================================================
/**
 * Week navigation hook
 * Handles navigation between weeks
 */
import { useCallback } from "react";
import { format, addDays, subDays, startOfWeek } from "date-fns";
import type { WeekChangeHandler } from "@/types";

/**
 * Week navigation hook
 * Provides functions for navigating between weeks
 *
 * @param currentWeekStart - Current week start date (Monday) in YYYY-MM-DD format
 * @param onWeekChange - Callback when week changes
 * @returns Navigation functions
 */
export function useWeekNavigation(currentWeekStart: string, onWeekChange: WeekChangeHandler) {
  /**
   * Navigate to previous week
   * Subtracts 7 days from current week start
   */
  const goToPreviousWeek = useCallback(() => {
    const currentDate = new Date(currentWeekStart);
    const previousWeek = subDays(currentDate, 7);
    const newWeekStart = format(previousWeek, "yyyy-MM-dd");
    onWeekChange(newWeekStart);
  }, [currentWeekStart, onWeekChange]);

  /**
   * Navigate to next week
   * Adds 7 days to current week start
   */
  const goToNextWeek = useCallback(() => {
    const currentDate = new Date(currentWeekStart);
    const nextWeek = addDays(currentDate, 7);
    const newWeekStart = format(nextWeek, "yyyy-MM-dd");
    onWeekChange(newWeekStart);
  }, [currentWeekStart, onWeekChange]);

  /**
   * Navigate to current week
   * Resets to current week (Monday)
   */
  const goToCurrentWeek = useCallback(() => {
    const today = new Date();
    const monday = startOfWeek(today, { weekStartsOn: 1 }); // 1 = Monday
    const currentWeek = format(monday, "yyyy-MM-dd");
    onWeekChange(currentWeek);
  }, [onWeekChange]);

  return {
    goToPreviousWeek,
    goToNextWeek,
    goToCurrentWeek,
  };
}



================================================
FILE: src/components/providers/QueryProvider.tsx
================================================
/**
 * TanStack Query Provider for React Query
 * Provides query client context to all child components
 */
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState } from "react";

export function QueryProvider({ children }: { children: React.ReactNode }) {
  // Create query client with configuration
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Stale time: 0 for meal plan (always fresh)
            staleTime: 0,
            // Refetch on window focus
            refetchOnWindowFocus: true,
            // Retry failed requests 3 times
            retry: 3,
            // Exponential backoff
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
          mutations: {
            // Retry mutations once
            retry: 1,
          },
        },
      })
  );

  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}



================================================
FILE: src/components/recipes/AddRecipeButton.tsx
================================================
/**
 * Add Recipe Button Component
 * Button for navigating to recipe creation page
 * Supports two variants: normal (desktop) and FAB (mobile)
 */
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface AddRecipeButtonProps {
  variant?: "normal" | "fab";
  className?: string;
}

/**
 * Add Recipe Button Component
 * Two variants:
 * - normal: Regular button for desktop header
 * - fab: Floating Action Button for mobile (sticky bottom-right)
 */
export function AddRecipeButton({ variant = "normal", className }: AddRecipeButtonProps) {
  const isFab = variant === "fab";

  return (
    <a href="/recipes/new" className={className}>
      <Button
        variant={isFab ? "default" : "default"}
        size={isFab ? "lg" : "default"}
        className={cn(isFab && "rounded-full w-14 h-14 shadow-lg hover:shadow-xl transition-shadow", !isFab && "gap-2")}
        aria-label="Dodaj nowy przepis"
      >
        {isFab ? (
          <Plus className="h-6 w-6" />
        ) : (
          <>
            <Plus className="h-4 w-4" />
            Dodaj przepis
          </>
        )}
      </Button>
    </a>
  );
}



================================================
FILE: src/components/recipes/AssignmentsInfo.tsx
================================================
/**
 * Assignments Info - alert informacyjny o przypisaniach przepisu do kalendarza
 * Wyświetla liczbę przypisań i link do kalendarza
 */
import { Info } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

interface AssignmentsInfoProps {
  count: number;
}

/**
 * AssignmentsInfo
 * Alert informacyjny wyświetlany gdy przepis jest przypisany do kalendarza posiłków
 * Pokazuje liczbę przypisań i link do kalendarza
 */
export function AssignmentsInfo({ count }: AssignmentsInfoProps) {
  // Plural forms for Polish
  const mealLabel = count === 1 ? "posiłku" : "posiłków";

  return (
    <Alert variant="default" className="mt-8 bg-blue-50 border-blue-200">
      <Info className="h-4 w-4 text-blue-600" aria-hidden="true" />
      <AlertTitle className="text-blue-900">Ten przepis jest przypisany do kalendarza</AlertTitle>
      <AlertDescription className="text-blue-800">
        Ten przepis jest przypisany do {count} {mealLabel} w kalendarzu.{" "}
        <a
          href="/calendar"
          className="font-medium underline hover:no-underline focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded"
        >
          Zobacz kalendarz →
        </a>
      </AlertDescription>
    </Alert>
  );
}



================================================
FILE: src/components/recipes/DeleteConfirmationDialog.tsx
================================================
/**
 * Delete Confirmation Dialog - dialog potwierdzający usunięcie przepisu
 * Wyświetla komunikat o konsekwencjach (usunięcie przypisań w kalendarzu)
 */
import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

interface DeleteConfirmationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  recipeId: string;
  recipeName: string;
  assignmentsCount: number;
  onConfirm: () => void;
  isDeleting: boolean;
}

/**
 * DeleteConfirmationDialog
 * Modal dialog potwierdzający usunięcie przepisu
 * Wyświetla komunikat o konsekwencjach (usunięcie przypisań w kalendarzu jeśli istnieją)
 */
export function DeleteConfirmationDialog({
  isOpen,
  onClose,
  recipeName,
  assignmentsCount,
  onConfirm,
  isDeleting,
}: DeleteConfirmationDialogProps) {
  // Plural forms for Polish
  const mealLabel = assignmentsCount === 1 ? "posiłku" : "posiłków";

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Usuń przepis?</DialogTitle>
          <DialogDescription>
            {assignmentsCount > 0 ? (
              <>
                Ten przepis &quot;{recipeName}&quot; jest przypisany do{" "}
                <strong>
                  {assignmentsCount} {mealLabel}
                </strong>{" "}
                w kalendarzu. Usunięcie spowoduje usunięcie wszystkich przypisań.
              </>
            ) : (
              <>Czy na pewno chcesz usunąć przepis &quot;{recipeName}&quot;?</>
            )}
          </DialogDescription>
        </DialogHeader>

        <DialogFooter>
          <Button variant="ghost" onClick={onClose} disabled={isDeleting}>
            Anuluj
          </Button>

          <Button variant="destructive" onClick={onConfirm} disabled={isDeleting}>
            {isDeleting ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" aria-hidden="true" />
                Usuwanie...
              </>
            ) : assignmentsCount > 0 ? (
              "Usuń przepis i przypisania"
            ) : (
              "Usuń przepis"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: src/components/recipes/DiscardChangesDialog.tsx
================================================
/**
 * Discard Changes Dialog Component
 * Confirmation dialog for discarding unsaved changes
 */
import { memo } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

interface DiscardChangesDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onDiscard: () => void;
}

/**
 * Discard Changes Dialog
 * Shows confirmation dialog when user tries to leave form with unsaved changes
 */
export const DiscardChangesDialog = memo<DiscardChangesDialogProps>(({ isOpen, onClose, onDiscard }) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Odrzucić zmiany?</DialogTitle>
          <DialogDescription>
            Masz niezapisane zmiany. Czy na pewno chcesz opuścić stronę? Wszystkie zmiany zostaną utracone.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter>
          <Button variant="ghost" onClick={onClose}>
            Kontynuuj edycję
          </Button>
          <Button variant="destructive" onClick={onDiscard}>
            Odrzuć zmiany
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
});

DiscardChangesDialog.displayName = "DiscardChangesDialog";



================================================
FILE: src/components/recipes/EmptyState.tsx
================================================
/**
 * Empty State Component for Recipes List
 * Displays different states when no recipes are found
 */
import { SearchX, ChefHat, Plus } from "lucide-react";
import { Button } from "@/components/ui/button";

interface EmptyStateProps {
  hasSearch: boolean;
  search?: string;
  onClearSearch?: () => void;
}

/**
 * Empty State Component
 * Two variants:
 * 1. Search results empty (hasSearch=true) - shows clear button
 * 2. No recipes at all (hasSearch=false) - shows CTA to add first recipe
 */
export function EmptyState({ hasSearch, search, onClearSearch }: EmptyStateProps) {
  return (
    <div className="empty-state py-16 text-center">
      <div className="max-w-md mx-auto">
        {hasSearch ? (
          // Variant 1: Empty search results
          <>
            <SearchX className="h-16 w-16 mx-auto text-gray-400 mb-4" aria-hidden="true" />
            <h2 className="text-2xl font-semibold text-gray-900 mb-2">Brak wyników wyszukiwania</h2>
            <p className="text-gray-600 mb-6">Nie znaleziono przepisów pasujących do &quot;{search}&quot;</p>
            <Button onClick={onClearSearch} variant="outline">
              Wyczyść wyszukiwanie
            </Button>
          </>
        ) : (
          // Variant 2: No recipes at all (new user)
          <>
            <ChefHat className="h-16 w-16 mx-auto text-gray-400 mb-4" aria-hidden="true" />
            <h2 className="text-2xl font-semibold text-gray-900 mb-2">Brak przepisów</h2>
            <p className="text-gray-600 mb-6">Dodaj pierwszy przepis, aby rozpocząć planowanie posiłków</p>
            <Button asChild size="lg">
              <a href="/recipes/new" className="inline-flex items-center gap-2">
                <Plus className="h-4 w-4" />
                Dodaj pierwszy przepis
              </a>
            </Button>
          </>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/ErrorMessage.tsx
================================================
/**
 * Error Message Component for Recipes List
 * Displays error state with retry option
 */
import { AlertCircle, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorMessageProps {
  error: Error;
  onRetry: () => void;
}

/**
 * Error Message Component
 * Displays error message with icon and retry button
 * Used when API requests fail
 */
export function ErrorMessage({ error, onRetry }: ErrorMessageProps) {
  return (
    <div className="error-message py-16 text-center">
      <div className="max-w-md mx-auto">
        <AlertCircle className="h-16 w-16 mx-auto text-red-500 mb-4" aria-hidden="true" />
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">Wystąpił błąd</h2>
        <p className="text-gray-600 mb-6">{error.message || "Nie udało się załadować przepisów"}</p>
        <Button onClick={onRetry} variant="outline" className="inline-flex items-center gap-2">
          <RefreshCw className="h-4 w-4" />
          Spróbuj ponownie
        </Button>
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/FormActions.tsx
================================================
/**
 * Form Actions Component
 * Sticky footer with Cancel and Save buttons
 */
import { memo } from "react";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";

interface FormActionsProps {
  onCancel: () => void;
  isSubmitting: boolean;
  isValid: boolean;
  mode?: "create" | "edit";
}

/**
 * Form Actions Component
 * Sticky bottom bar with form action buttons
 */
export const FormActions = memo<FormActionsProps>(({ onCancel, isSubmitting, isValid, mode = "create" }) => {
  const isEdit = mode === "edit";

  return (
    <div className="form-actions sticky bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-4 shadow-lg mt-8 -mx-4">
      <div className="container mx-auto max-w-3xl flex gap-4 justify-end">
        <Button type="button" onClick={onCancel} variant="ghost" disabled={isSubmitting} className="min-w-24">
          Anuluj
        </Button>

        <Button type="submit" disabled={!isValid || isSubmitting} className="min-w-32">
          {isSubmitting ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              {isEdit ? "Aktualizowanie..." : "Zapisywanie..."}
            </>
          ) : isEdit ? (
            "Zapisz zmiany"
          ) : (
            "Zapisz przepis"
          )}
        </Button>
      </div>
    </div>
  );
});

FormActions.displayName = "FormActions";



================================================
FILE: src/components/recipes/FormHeader.tsx
================================================
/**
 * Form Header Component
 * Header with breadcrumbs and title for recipe form
 */
import { memo } from "react";

/**
 * Breadcrumbs Component
 * Simple breadcrumbs navigation
 */
const Breadcrumbs = memo<{ items: { label: string; href: string }[] }>(({ items }) => {
  return (
    <nav aria-label="Breadcrumb" className="mb-4">
      <ol className="flex items-center space-x-2 text-sm text-gray-600">
        {items.map((item, index) => (
          <li key={item.href} className="flex items-center">
            {index > 0 && <span className="mx-2 text-gray-400">/</span>}
            {index === items.length - 1 ? (
              <span className="text-gray-900 font-medium" aria-current="page">
                {item.label}
              </span>
            ) : (
              <a href={item.href} className="hover:text-blue-600 transition-colors">
                {item.label}
              </a>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
});

Breadcrumbs.displayName = "Breadcrumbs";

interface FormHeaderProps {
  mode?: "create" | "edit";
  recipeName?: string;
}

/**
 * Form Header Component
 * Displays breadcrumbs and page title
 */
export const FormHeader = memo<FormHeaderProps>(({ mode = "create", recipeName }) => {
  const isEdit = mode === "edit";
  const truncatedName = recipeName && recipeName.length > 30 ? `${recipeName.slice(0, 30)}...` : recipeName;

  return (
    <div className="form-header mb-8">
      <Breadcrumbs
        items={[
          { label: "Przepisy", href: "/recipes" },
          isEdit
            ? { label: truncatedName || "Edytuj przepis", href: "" }
            : { label: "Dodaj przepis", href: "/recipes/new" },
        ]}
      />

      <h1 className="text-3xl font-bold text-gray-900">{isEdit ? "Edytuj przepis" : "Dodaj nowy przepis"}</h1>
      <p className="text-gray-600 mt-2">
        {isEdit
          ? "Wprowadź zmiany w poniższym formularzu"
          : "Wypełnij poniższy formularz, aby dodać nowy przepis do swojej kolekcji"}
      </p>
    </div>
  );
});

FormHeader.displayName = "FormHeader";



================================================
FILE: src/components/recipes/IngredientRow.tsx
================================================
/**
 * Ingredient Row Component
 * Single row for ingredient input (quantity, unit, name, delete button)
 */
import { memo } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Trash2 } from "lucide-react";
import type { IngredientInputDto } from "@/types";

interface IngredientRowProps {
  index: number;
  ingredient: IngredientInputDto;
  onUpdate: (field: keyof IngredientInputDto, value: any) => void;
  onRemove: () => void;
  canRemove: boolean;
  error?: any;
}

/**
 * Ingredient Row Component
 * Displays inputs for quantity, unit, name and delete button
 */
export const IngredientRow = memo<IngredientRowProps>(({ index, ingredient, onUpdate, onRemove, canRemove, error }) => {
  return (
    <div className="ingredient-row">
      <div className="flex gap-2 items-start">
        {/* Quantity Input */}
        <div className="w-24">
          <Input
            type="number"
            value={ingredient.quantity ?? ""}
            onChange={(e) => onUpdate("quantity", e.target.value ? Number(e.target.value) : null)}
            placeholder="200"
            min="0"
            step="0.01"
            aria-label={`Ilość składnika ${index + 1}`}
            className="text-sm"
          />
        </div>

        {/* Unit Input */}
        <div className="w-24">
          <Input
            type="text"
            value={ingredient.unit ?? ""}
            onChange={(e) => onUpdate("unit", e.target.value || null)}
            placeholder="g"
            maxLength={50}
            aria-label={`Jednostka składnika ${index + 1}`}
            className="text-sm"
          />
        </div>

        {/* Name Input */}
        <div className="flex-1">
          <Input
            type="text"
            value={ingredient.name}
            onChange={(e) => onUpdate("name", e.target.value)}
            placeholder="np. mąka"
            maxLength={100}
            aria-invalid={!!error?.name}
            aria-describedby={error?.name ? `ingredient-${index}-error` : undefined}
            required
            className={`text-sm ${error?.name ? "border-red-500 focus-visible:ring-red-500" : ""}`}
            aria-label={`Nazwa składnika ${index + 1}`}
          />
        </div>

        {/* Delete Button */}
        <Button
          type="button"
          onClick={onRemove}
          variant="ghost"
          size="icon"
          disabled={!canRemove}
          aria-label={`Usuń składnik ${index + 1}`}
          className="flex-shrink-0 h-10 w-10 hover:bg-red-50 hover:text-red-700 disabled:opacity-50 disabled:cursor-not-allowed"
          title={!canRemove ? "Wymagany minimum 1 składnik" : "Usuń składnik"}
        >
          <Trash2 className="h-4 w-4" />
        </Button>
      </div>

      {/* Error Message */}
      {error?.name && (
        <p
          id={`ingredient-${index}-error`}
          className="text-sm text-red-600 mt-1 ml-1 flex items-center gap-1"
          role="alert"
        >
          <span>⚠</span> {error.name.message || error.name}
        </p>
      )}
    </div>
  );
});

IngredientRow.displayName = "IngredientRow";



================================================
FILE: src/components/recipes/IngredientsList.tsx
================================================
/**
 * Ingredients List Component
 * Dynamic list of ingredients with add/remove functionality
 */
import { memo } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { IngredientRow } from "./IngredientRow";
import type { IngredientInputDto } from "@/types";

interface IngredientsListProps {
  ingredients: (IngredientInputDto & { id: string })[];
  onAdd: (ingredient: IngredientInputDto) => void;
  onRemove: (index: number) => void;
  onUpdate: (index: number, field: keyof IngredientInputDto, value: any) => void;
  errors?: Record<number, any>;
}

/**
 * Ingredients List Component
 * Manages dynamic list of ingredient rows (min 1, max 50)
 */
export const IngredientsList = memo<IngredientsListProps>(({ ingredients, onAdd, onRemove, onUpdate, errors }) => {
  const canAddMore = ingredients.length < 50;
  const canRemove = ingredients.length > 1;

  const handleAddIngredient = () => {
    onAdd({
      name: "",
      quantity: null,
      unit: null,
      sort_order: ingredients.length,
    });
  };

  return (
    <div className="ingredients-list space-y-4">
      {/* Header */}
      <div>
        <Label className="text-base font-medium">
          Składniki <span className="text-red-500">*</span>
        </Label>
        <p className="text-sm text-gray-600 mt-1">
          Dodaj składniki (minimum 1, maksimum 50). Ilość i jednostka są opcjonalne.
        </p>
      </div>

      {/* Ingredients Rows */}
      <div className="space-y-3" role="list" aria-label="Lista składników">
        {ingredients.map((ingredient, index) => (
          <div key={ingredient.id} role="listitem">
            <IngredientRow
              index={index}
              ingredient={ingredient}
              onUpdate={(field, value) => onUpdate(index, field, value)}
              onRemove={() => onRemove(index)}
              canRemove={canRemove}
              error={errors?.[index]}
            />
          </div>
        ))}
      </div>

      {/* Add Ingredient Button */}
      <Button
        type="button"
        onClick={handleAddIngredient}
        variant="outline"
        disabled={!canAddMore}
        className="w-full border-dashed border-2 hover:border-blue-500 hover:bg-blue-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        title={!canAddMore ? "Osiągnięto maksimum 50 składników" : "Dodaj składnik"}
      >
        <Plus className="h-4 w-4 mr-2" />
        Dodaj składnik {!canAddMore && `(${ingredients.length}/50)`}
      </Button>

      {/* Helper text */}
      <div className="bg-blue-50 border border-blue-200 rounded-md p-3">
        <p className="text-xs text-blue-800">
          <strong>💡 Wskazówka:</strong> Ilość (np. 200) i jednostka (np. g, kg, sztuki) są opcjonalne. Nazwa składnika
          jest wymagana.
        </p>
      </div>
    </div>
  );
});

IngredientsList.displayName = "IngredientsList";



================================================
FILE: src/components/recipes/IngredientsSection.tsx
================================================
/**
 * Ingredients Section - sekcja ze składnikami przepisu
 * Wyświetla listę składników posortowaną według sort_order
 */
import type { IngredientResponseDto } from "@/types";

interface IngredientsSectionProps {
  ingredients: IngredientResponseDto[];
}

/**
 * IngredientsSection
 * Sekcja ze składnikami wyświetlana jako lista punktowana
 * Każdy składnik pokazuje ilość, jednostkę i nazwę
 */
export function IngredientsSection({ ingredients }: IngredientsSectionProps) {
  // Sort ingredients by sort_order
  const sortedIngredients = [...ingredients].sort((a, b) => a.sort_order - b.sort_order);

  return (
    <section className="ingredients-section" aria-labelledby="ingredients-heading">
      <h2 id="ingredients-heading" className="text-2xl font-semibold text-gray-900 mb-4">
        Składniki ({ingredients.length})
      </h2>

      <ul className="space-y-2" role="list">
        {sortedIngredients.map((ingredient) => (
          <li key={ingredient.id} className="flex items-baseline gap-2 text-gray-800">
            <span className="text-primary" aria-hidden="true">
              •
            </span>
            <span>
              {ingredient.quantity && <strong className="font-semibold">{ingredient.quantity} </strong>}
              {ingredient.unit && <span className="text-gray-600">{ingredient.unit} </span>}
              <span>{ingredient.name}</span>
            </span>
          </li>
        ))}
      </ul>
    </section>
  );
}



================================================
FILE: src/components/recipes/InstructionsSection.tsx
================================================
/**
 * Instructions Section - sekcja z instrukcjami przepisu
 * Wyświetla instrukcje z zachowaniem formatowania (newlines)
 */

interface InstructionsSectionProps {
  instructions: string;
}

/**
 * InstructionsSection
 * Sekcja z instrukcjami wyświetlana jako paragraph z zachowaniem formatowania
 */
export function InstructionsSection({ instructions }: InstructionsSectionProps) {
  return (
    <section className="instructions-section" aria-labelledby="instructions-heading">
      <h2 id="instructions-heading" className="text-2xl font-semibold text-gray-900 mb-4">
        Instrukcje
      </h2>

      <p className="whitespace-pre-wrap leading-relaxed text-gray-800">{instructions}</p>
    </section>
  );
}



================================================
FILE: src/components/recipes/InstructionsTextarea.tsx
================================================
/**
 * Instructions Textarea Component
 * Textarea for recipe instructions with character counter
 */
import { memo } from "react";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";

interface InstructionsTextareaProps {
  value: string;
  onChange: (value: string) => void;
  error?: string;
}

/**
 * Instructions Textarea Component
 * Displays textarea with character counter (max 5000)
 */
export const InstructionsTextarea = memo<InstructionsTextareaProps>(({ value, onChange, error }) => {
  const charCount = value.length;
  const maxChars = 5000;
  const isNearLimit = charCount > maxChars * 0.9;

  return (
    <div className="instructions-field space-y-2">
      <Label htmlFor="recipe-instructions" className="text-base font-medium">
        Instrukcje <span className="text-red-500">*</span>
      </Label>
      <Textarea
        id="recipe-instructions"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder="Opisz krok po kroku jak przygotować przepis...

1. Przygotuj składniki
2. ..."
        rows={8}
        className={`resize-none ${error ? "border-red-500 focus-visible:ring-red-500" : ""}`}
        aria-invalid={!!error}
        aria-describedby={error ? "instructions-error" : "instructions-counter"}
      />
      <div className="flex justify-between items-center">
        <p
          id="instructions-counter"
          className={`text-sm ${isNearLimit ? "text-orange-600 font-medium" : "text-gray-600"}`}
          aria-live="polite"
        >
          {charCount}/{maxChars}
        </p>
        {error && (
          <p id="instructions-error" className="text-sm text-red-600 flex items-center gap-1" role="alert">
            <span>⚠</span> {error}
          </p>
        )}
      </div>
    </div>
  );
});

InstructionsTextarea.displayName = "InstructionsTextarea";



================================================
FILE: src/components/recipes/NameInput.tsx
================================================
/**
 * Name Input Component
 * Input field for recipe name with validation
 */
import { memo } from "react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";

interface NameInputProps {
  value: string;
  onChange: (value: string) => void;
  error?: string;
}

/**
 * Name Input Component
 * Displays input for recipe name with error messages
 */
export const NameInput = memo<NameInputProps>(({ value, onChange, error }) => {
  return (
    <div className="name-input-field space-y-2">
      <Label htmlFor="recipe-name" className="text-base font-medium">
        Nazwa przepisu <span className="text-red-500">*</span>
      </Label>
      <Input
        id="recipe-name"
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder="np. Spaghetti Carbonara"
        aria-invalid={!!error}
        aria-describedby={error ? "name-error" : undefined}
        autoFocus
        className={error ? "border-red-500 focus-visible:ring-red-500" : ""}
      />
      {error && (
        <p id="name-error" className="text-sm text-red-600 flex items-center gap-1" role="alert">
          <span>⚠</span> {error}
        </p>
      )}
    </div>
  );
});

NameInput.displayName = "NameInput";



================================================
FILE: src/components/recipes/RecipeCard.tsx
================================================
/**
 * Recipe Card Component
 * Displays a single recipe in the recipes list grid
 */
import { ChefHat, Clock } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { truncate } from "@/lib/utils/text";
import { formatRelativeTime } from "@/lib/utils/date";
import type { RecipeListItemDto } from "@/types";

interface RecipeCardProps {
  recipe: RecipeListItemDto;
  onPrefetch?: (recipeId: string) => void;
}

/**
 * Recipe Card Component
 * Clickable card showing recipe name, ingredients count and creation date
 * Implements prefetching on hover for better UX
 */
export function RecipeCard({ recipe, onPrefetch }: RecipeCardProps) {
  const displayName = truncate(recipe.name, 50);
  const isNameTruncated = recipe.name.length > 50;

  /**
   * Handle mouse enter for prefetching
   * Prefetches recipe details for instant navigation
   */
  const handleMouseEnter = () => {
    if (onPrefetch) {
      onPrefetch(recipe.id);
    }
  };

  return (
    <a href={`/recipes/${recipe.id}`} onMouseEnter={handleMouseEnter} className="recipe-card block">
      <article className="border rounded-lg p-6 hover:shadow-lg transition-shadow bg-white h-full">
        {/* Recipe name with truncation */}
        <h3
          className="text-lg font-semibold text-gray-900 mb-3 line-clamp-2"
          title={isNameTruncated ? recipe.name : undefined}
        >
          {displayName}
        </h3>

        {/* Metadata: ingredients count and creation date */}
        <div className="flex items-center gap-3 text-sm text-gray-600 flex-wrap">
          {/* Ingredients count badge */}
          <Badge variant="secondary" className="flex items-center gap-1">
            <ChefHat className="h-3 w-3" />
            <span>
              {recipe.ingredients_count} {recipe.ingredients_count === 1 ? "składnik" : "składników"}
            </span>
          </Badge>

          {/* Creation date (relative) */}
          <time
            dateTime={recipe.created_at}
            className="flex items-center gap-1"
            title={new Date(recipe.created_at).toLocaleString("pl-PL")}
          >
            <Clock className="h-3 w-3" />
            {formatRelativeTime(recipe.created_at)}
          </time>
        </div>
      </article>
    </a>
  );
}



================================================
FILE: src/components/recipes/RecipeCardSkeleton.tsx
================================================
/**
 * Recipe Card Skeleton Component
 * Loading placeholder for RecipeCard with matching layout
 */
import { Skeleton } from "@/components/ui/skeleton";

/**
 * Recipe Card Skeleton Component
 * Displays a skeleton loader matching RecipeCard layout
 * Used during initial load and infinite scroll
 */
export function RecipeCardSkeleton() {
  return (
    <div className="recipe-card-skeleton border rounded-lg p-6 bg-white h-full">
      {/* Title skeleton (2 lines) */}
      <Skeleton className="h-6 w-3/4 mb-2" />
      <Skeleton className="h-6 w-1/2 mb-3" />

      {/* Metadata skeleton (badges) */}
      <div className="flex items-center gap-3">
        <Skeleton className="h-5 w-24" />
        <Skeleton className="h-5 w-20" />
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipeCreateView.tsx
================================================
/**
 * Recipe Create View Component
 * Main container for recipe creation form
 */
import { QueryProvider } from "@/components/providers/QueryProvider";
import { Toaster } from "@/components/ui/toaster";
import { RecipeForm } from "./RecipeForm";

/**
 * Recipe Create View Component
 * Wraps RecipeForm with QueryProvider for TanStack Query
 */
export default function RecipeCreateView() {
  return (
    <QueryProvider>
      <div className="recipe-create-view min-h-screen bg-gray-50">
        <div className="container mx-auto max-w-3xl p-4 py-8">
          <RecipeForm />
        </div>
      </div>
      <Toaster />
    </QueryProvider>
  );
}



================================================
FILE: src/components/recipes/RecipeDetailsContent.tsx
================================================
/**
 * Recipe Details Content - główna zawartość strony szczegółów przepisu
 * Wyświetla nazwę, meta dane, składniki, instrukcje i info o przypisaniach
 */
import type { RecipeResponseDto } from "@/types";
import { RecipeMeta } from "./RecipeMeta";
import { IngredientsSection } from "./IngredientsSection";
import { InstructionsSection } from "./InstructionsSection";
import { AssignmentsInfo } from "./AssignmentsInfo";

interface RecipeDetailsContentProps {
  recipe: RecipeResponseDto;
}

/**
 * RecipeDetailsContent
 * Główna zawartość strony z nazwą przepisu, meta informacjami,
 * składnikami i instrukcjami
 */
export function RecipeDetailsContent({ recipe }: RecipeDetailsContentProps) {
  return (
    <div className="recipe-details-content container mx-auto max-w-4xl px-4 py-8">
      {/* Recipe name */}
      <h1 className="text-4xl font-bold text-gray-900 mb-2">{recipe.name}</h1>

      {/* Meta information */}
      <RecipeMeta createdAt={recipe.created_at} updatedAt={recipe.updated_at} />

      {/* Ingredients and Instructions grid */}
      <div className="grid md:grid-cols-2 gap-8 mt-8">
        <IngredientsSection ingredients={recipe.ingredients} />
        <InstructionsSection instructions={recipe.instructions} />
      </div>

      {/* Assignments info (conditional) */}
      {recipe.meal_plan_assignments && recipe.meal_plan_assignments > 0 && (
        <AssignmentsInfo count={recipe.meal_plan_assignments} />
      )}
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipeDetailsHeader.tsx
================================================
/**
 * Recipe Details Header - sticky header z breadcrumbs i przyciskami akcji
 * Zawiera nawigację (breadcrumbs) i przyciski: Edytuj, Usuń, Powrót
 */
import { Edit, Trash2, ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";

interface RecipeDetailsHeaderProps {
  recipeName: string;
  recipeId: string;
  onDelete: () => void;
}

/**
 * RecipeDetailsHeader
 * Sticky header z breadcrumbs i przyciskami akcji
 */
export function RecipeDetailsHeader({ recipeName, recipeId, onDelete }: RecipeDetailsHeaderProps) {
  // Truncate recipe name if too long for breadcrumb
  const truncatedName = recipeName.length > 30 ? `${recipeName.slice(0, 30)}...` : recipeName;

  return (
    <header className="recipe-details-header sticky top-0 bg-white z-10 border-b shadow-sm">
      <div className="container mx-auto max-w-7xl px-4 py-4">
        {/* Breadcrumbs */}
        <Breadcrumb className="mb-4">
          <BreadcrumbList>
            <BreadcrumbItem>
              <BreadcrumbLink href="/recipes">Przepisy</BreadcrumbLink>
            </BreadcrumbItem>
            <BreadcrumbSeparator />
            <BreadcrumbItem>
              <BreadcrumbPage>{truncatedName}</BreadcrumbPage>
            </BreadcrumbItem>
          </BreadcrumbList>
        </Breadcrumb>

        {/* Action buttons */}
        <div className="flex flex-wrap gap-3">
          <Button asChild variant="outline">
            <a href={`/recipes/${recipeId}/edit`}>
              <Edit className="h-4 w-4 mr-2" aria-hidden="true" />
              Edytuj
            </a>
          </Button>

          <Button onClick={onDelete} variant="destructive" aria-label={`Usuń przepis ${recipeName}`}>
            <Trash2 className="h-4 w-4 mr-2" aria-hidden="true" />
            Usuń
          </Button>

          <Button asChild variant="ghost">
            <a href="/recipes">
              <ArrowLeft className="h-4 w-4 mr-2" aria-hidden="true" />
              Powrót do listy
            </a>
          </Button>
        </div>
      </div>
    </header>
  );
}



================================================
FILE: src/components/recipes/RecipeDetailsSkeleton.tsx
================================================
/**
 * Recipe Details Skeleton - skeleton loader dla widoku szczegółów przepisu
 * Wyświetlany podczas ładowania danych
 */
import { Skeleton } from "@/components/ui/skeleton";

/**
 * RecipeDetailsSkeleton
 * Skeleton loader podczas ładowania szczegółów przepisu
 */
export function RecipeDetailsSkeleton() {
  return (
    <div className="recipe-details-skeleton">
      {/* Header skeleton */}
      <div className="border-b bg-white shadow-sm">
        <div className="container mx-auto max-w-7xl px-4 py-4">
          {/* Breadcrumbs skeleton */}
          <div className="flex items-center gap-2 mb-4">
            <Skeleton className="h-4 w-20" />
            <Skeleton className="h-4 w-4" />
            <Skeleton className="h-4 w-32" />
          </div>

          {/* Buttons skeleton */}
          <div className="flex gap-3">
            <Skeleton className="h-10 w-24" />
            <Skeleton className="h-10 w-20" />
            <Skeleton className="h-10 w-32" />
          </div>
        </div>
      </div>

      {/* Content skeleton */}
      <div className="container mx-auto max-w-4xl px-4 py-8">
        {/* Title skeleton */}
        <Skeleton className="h-10 w-3/4 mb-2" />

        {/* Meta skeleton */}
        <div className="flex gap-4 mb-8">
          <Skeleton className="h-4 w-48" />
          <Skeleton className="h-4 w-48" />
        </div>

        {/* Grid skeleton */}
        <div className="grid md:grid-cols-2 gap-8">
          {/* Ingredients skeleton */}
          <div>
            <Skeleton className="h-6 w-32 mb-4" />
            <div className="space-y-2">
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-5/6" />
              <Skeleton className="h-4 w-4/5" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-3/4" />
            </div>
          </div>

          {/* Instructions skeleton */}
          <div>
            <Skeleton className="h-6 w-32 mb-4" />
            <div className="space-y-2">
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-4/5" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-5/6" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-3/4" />
              <Skeleton className="h-4 w-full" />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipeDetailsView.tsx
================================================
/**
 * Recipe Details View - główny kontener widoku szczegółów przepisu
 * Zarządza stanem, pobiera dane z API i renderuje komponenty dziecięce
 */
import React from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import type { RecipeResponseDto, DeleteRecipeResponseDto } from "@/types";
import { RecipeDetailsHeader } from "./RecipeDetailsHeader";
import { RecipeDetailsContent } from "./RecipeDetailsContent";
import { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
import { RecipeDetailsSkeleton } from "./RecipeDetailsSkeleton";
import { ErrorMessage } from "./ErrorMessage";

interface RecipeDetailsViewProps {
  recipeId: string;
}

/**
 * RecipeDetailsView
 * Główny komponent widoku szczegółów przepisu
 */
export function RecipeDetailsView({ recipeId }: RecipeDetailsViewProps) {
  const queryClient = useQueryClient();
  const [deleteDialogOpen, setDeleteDialogOpen] = React.useState(false);

  // Fetch recipe details
  const {
    data: recipe,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["recipe", recipeId],
    queryFn: async () => {
      const response = await fetch(`/api/recipes/${recipeId}`);

      if (response.status === 404) {
        throw new Error("Recipe not found");
      }

      if (!response.ok) {
        throw new Error("Failed to fetch recipe");
      }

      return response.json() as Promise<RecipeResponseDto>;
    },
    staleTime: 10 * 60 * 1000, // 10 minut
    retry: (failureCount, error) => {
      // Don't retry 404
      if (error instanceof Error && error.message === "Recipe not found") {
        return false;
      }
      return failureCount < 2;
    },
  });

  // Delete mutation
  const deleteMutation = useMutation({
    mutationFn: async () => {
      const response = await fetch(`/api/recipes/${recipeId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete recipe");
      }

      return response.json() as Promise<DeleteRecipeResponseDto>;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["recipes"] });
      queryClient.invalidateQueries({ queryKey: ["meal-plan"] }); // May be assigned

      toast.success(
        data.deleted_meal_plan_assignments > 0
          ? `Przepis usunięty wraz z ${data.deleted_meal_plan_assignments} przypisaniami`
          : "Przepis usunięty"
      );

      // Redirect to recipes list
      window.location.href = "/recipes";
    },
    onError: (error: Error) => {
      toast.error(error.message || "Nie udało się usunąć przepisu");
    },
  });

  // Handle loading state
  if (isLoading) {
    return <RecipeDetailsSkeleton />;
  }

  // Handle error state
  if (error) {
    // 404 error - show not found message
    if (error instanceof Error && error.message === "Recipe not found") {
      return (
        <div className="py-16 text-center">
          <div className="max-w-md mx-auto">
            <h2 className="text-2xl font-semibold text-gray-900 mb-2">Przepis nie znaleziony</h2>
            <p className="text-gray-600 mb-6">Przepis o podanym ID nie istnieje lub nie masz do niego dostępu.</p>
            <a href="/recipes" className="inline-flex items-center gap-2 text-primary hover:underline">
              Powrót do listy przepisów
            </a>
          </div>
        </div>
      );
    }

    // Other errors - show error message with retry
    return <ErrorMessage error={error} onRetry={() => refetch()} />;
  }

  // Handle no data
  if (!recipe) {
    return null;
  }

  // Render recipe details
  return (
    <div className="recipe-details-view">
      <RecipeDetailsHeader recipeName={recipe.name} recipeId={recipe.id} onDelete={() => setDeleteDialogOpen(true)} />

      <RecipeDetailsContent recipe={recipe} />

      <DeleteConfirmationDialog
        isOpen={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
        recipeId={recipe.id}
        recipeName={recipe.name}
        assignmentsCount={recipe.meal_plan_assignments ?? 0}
        onConfirm={() => deleteMutation.mutate()}
        isDeleting={deleteMutation.isPending}
      />
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipeEditView.tsx
================================================
/**
 * Recipe Edit View Component
 * Main container for recipe editing form with data fetching
 */
import React from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useForm, useFieldArray, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { toast } from "sonner";
import { Info } from "lucide-react";
import { RecipeSchema, type RecipeSchemaType } from "@/lib/validation/recipe.schema";
import type { RecipeResponseDto } from "@/types";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { FormHeader } from "./FormHeader";
import { NameInput } from "./NameInput";
import { InstructionsTextarea } from "./InstructionsTextarea";
import { IngredientsList } from "./IngredientsList";
import { FormActions } from "./FormActions";
import { DiscardChangesDialog } from "./DiscardChangesDialog";
import { RecipeDetailsSkeleton } from "./RecipeDetailsSkeleton";
import { ErrorMessage } from "./ErrorMessage";

interface RecipeEditViewProps {
  recipeId: string;
}

/**
 * Recipe Edit View Component
 * Fetches recipe data and provides editing form
 */
export function RecipeEditView({ recipeId }: RecipeEditViewProps) {
  const queryClient = useQueryClient();
  const [discardDialogOpen, setDiscardDialogOpen] = React.useState(false);

  // Fetch recipe details
  const {
    data: recipe,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["recipe", recipeId],
    queryFn: async () => {
      const response = await fetch(`/api/recipes/${recipeId}`);

      if (response.status === 404) {
        throw new Error("Recipe not found");
      }

      if (!response.ok) {
        throw new Error("Failed to fetch recipe");
      }

      return response.json() as Promise<RecipeResponseDto>;
    },
    staleTime: 5 * 60 * 1000, // 5 minut
    retry: (failureCount, error) => {
      if (error instanceof Error && error.message === "Recipe not found") {
        return false;
      }
      return failureCount < 2;
    },
  });

  // Setup react-hook-form with Zod validation
  const {
    control,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isValid, isDirty },
    reset,
  } = useForm<RecipeSchemaType>({
    resolver: zodResolver(RecipeSchema),
    mode: "onChange",
    defaultValues: {
      name: "",
      instructions: "",
      ingredients: [{ name: "", quantity: null, unit: null, sort_order: 0 }],
    },
  });

  // Reset form with fetched data
  React.useEffect(() => {
    if (recipe) {
      reset({
        name: recipe.name,
        instructions: recipe.instructions,
        ingredients: recipe.ingredients.map((ing) => ({
          name: ing.name,
          quantity: ing.quantity,
          unit: ing.unit,
          sort_order: ing.sort_order,
        })),
      });
    }
  }, [recipe, reset]);

  // Setup field array for dynamic ingredients
  const { fields, append, remove, update } = useFieldArray({
    control,
    name: "ingredients",
  });

  // Setup mutation for PUT /api/recipes/:id
  const mutation = useMutation({
    mutationFn: async (data: RecipeSchemaType) => {
      const response = await fetch(`/api/recipes/${recipeId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || errorData.message || "Nie udało się zaktualizować przepisu");
      }

      return response.json() as Promise<RecipeResponseDto>;
    },
    onSuccess: (updatedRecipe) => {
      // Invalidate all related queries
      queryClient.invalidateQueries({ queryKey: ["recipe", recipeId] });
      queryClient.invalidateQueries({ queryKey: ["recipes"] });
      queryClient.invalidateQueries({ queryKey: ["meal-plan"] }); // Live update in calendar

      // Show success notification
      toast.success("Przepis zaktualizowany pomyślnie!", {
        description: "Przekierowywanie do szczegółów przepisu...",
      });

      // Redirect to recipe details after short delay
      setTimeout(() => {
        window.location.href = `/recipes/${updatedRecipe.id}`;
      }, 1000);
    },
    onError: (error: Error) => {
      // Show error notification
      toast.error("Nie udało się zaktualizować przepisu", {
        description: error.message || "Sprawdź połączenie z internetem i spróbuj ponownie.",
      });
      console.error("Recipe update error:", error);
    },
  });

  // Submit handler
  const onSubmit = (data: RecipeSchemaType) => {
    // Assign sort_order based on array index
    const dataWithSortOrder: RecipeSchemaType = {
      ...data,
      ingredients: data.ingredients.map((ing, index) => ({
        ...ing,
        sort_order: index,
      })),
    };

    mutation.mutate(dataWithSortOrder);
  };

  // Cancel handler with dirty check
  const handleCancel = () => {
    if (isDirty) {
      setDiscardDialogOpen(true);
    } else {
      window.location.href = `/recipes/${recipeId}`;
    }
  };

  // Handle discard action from dialog
  const handleDiscard = () => {
    window.location.href = `/recipes/${recipeId}`;
  };

  // Handle loading state
  if (isLoading) {
    return (
      <div className="recipe-edit-view min-h-screen bg-gray-50">
        <div className="container mx-auto max-w-3xl p-4 py-8">
          <RecipeDetailsSkeleton />
        </div>
      </div>
    );
  }

  // Handle error state
  if (error) {
    // 404 error - show not found message
    if (error instanceof Error && error.message === "Recipe not found") {
      return (
        <div className="recipe-edit-view min-h-screen bg-gray-50">
          <div className="container mx-auto max-w-3xl p-4 py-16 text-center">
            <div className="max-w-md mx-auto">
              <h2 className="text-2xl font-semibold text-gray-900 mb-2">Przepis nie znaleziony</h2>
              <p className="text-gray-600 mb-6">Przepis o podanym ID nie istnieje lub nie masz do niego dostępu.</p>
              <a href="/recipes" className="inline-flex items-center gap-2 text-primary hover:underline">
                Powrót do listy przepisów
              </a>
            </div>
          </div>
        </div>
      );
    }

    // Other errors - show error message with retry
    return (
      <div className="recipe-edit-view min-h-screen bg-gray-50">
        <div className="container mx-auto max-w-3xl p-4 py-8">
          <ErrorMessage error={error} onRetry={() => refetch()} />
        </div>
      </div>
    );
  }

  // Handle no data
  if (!recipe) {
    return null;
  }

  // Render edit form
  return (
    <div className="recipe-edit-view min-h-screen bg-gray-50">
      <div className="container mx-auto max-w-3xl p-4 py-8">
        <form
          onSubmit={handleSubmit(onSubmit)}
          className="recipe-form bg-white rounded-lg shadow-sm p-6 sm:p-8"
          noValidate
          aria-label="Formularz edycji przepisu"
        >
          {/* Header with breadcrumbs */}
          <FormHeader mode="edit" recipeName={recipe.name} />

          {/* Info Alert about propagation */}
          <Alert className="my-6">
            <Info className="h-4 w-4" />
            <AlertDescription>
              Zmiany zaktualizują wszystkie przypisania w kalendarzu. Wcześniej wygenerowane listy zakupów pozostaną
              niezmienione (snapshot).
            </AlertDescription>
          </Alert>

          {/* Form Fields */}
          <div className="space-y-8">
            {/* Name Input */}
            <Controller
              name="name"
              control={control}
              render={({ field }) => (
                <NameInput value={field.value} onChange={field.onChange} error={errors.name?.message} />
              )}
            />

            {/* Instructions Textarea */}
            <Controller
              name="instructions"
              control={control}
              render={({ field }) => (
                <InstructionsTextarea
                  value={field.value}
                  onChange={field.onChange}
                  error={errors.instructions?.message}
                />
              )}
            />

            {/* Ingredients List */}
            <IngredientsList
              ingredients={fields}
              onAdd={append}
              onRemove={remove}
              onUpdate={(index, field, value) => {
                const ingredient = fields[index];
                update(index, { ...ingredient, [field]: value });
              }}
              errors={errors.ingredients as any}
            />
          </div>

          {/* Form Actions (sticky bottom) */}
          <FormActions onCancel={handleCancel} isSubmitting={mutation.isPending} isValid={isValid} mode="edit" />
        </form>

        {/* Discard Changes Dialog */}
        <DiscardChangesDialog
          isOpen={discardDialogOpen}
          onClose={() => setDiscardDialogOpen(false)}
          onDiscard={handleDiscard}
        />
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipeForm.tsx
================================================
/**
 * Recipe Form Component
 * Main form for creating recipes with react-hook-form and TanStack Query
 */
import { useForm, useFieldArray, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { toast } from "sonner";
import { FormHeader } from "./FormHeader";
import { NameInput } from "./NameInput";
import { InstructionsTextarea } from "./InstructionsTextarea";
import { IngredientsList } from "./IngredientsList";
import { FormActions } from "./FormActions";
import { RecipeSchema, type RecipeSchemaType } from "@/lib/validation/recipe.schema";
import type { RecipeResponseDto } from "@/types";

/**
 * Recipe Form Component
 * Manages form state, validation, and submission
 */
export function RecipeForm() {
  // Setup react-hook-form with Zod validation
  const {
    control,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isValid },
  } = useForm<RecipeSchemaType>({
    resolver: zodResolver(RecipeSchema),
    mode: "onChange", // Validate on change for instant feedback
    defaultValues: {
      name: "",
      instructions: "",
      ingredients: [{ name: "", quantity: null, unit: null, sort_order: 0 }],
    },
  });

  // Setup field array for dynamic ingredients
  const { fields, append, remove, update } = useFieldArray({
    control,
    name: "ingredients",
  });

  // Setup mutation for POST /api/recipes
  const mutation = useMutation({
    mutationFn: async (data: RecipeSchemaType) => {
      const response = await fetch("/api/recipes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || errorData.message || "Nie udało się dodać przepisu");
      }

      return response.json() as Promise<RecipeResponseDto>;
    },
    onSuccess: (newRecipe) => {
      // Show success notification
      toast.success("Przepis dodany pomyślnie!", {
        description: `Przekierowywanie do szczegółów przepisu...`,
      });
      // Redirect to recipe details after short delay
      setTimeout(() => {
        window.location.href = `/recipes/${newRecipe.id}`;
      }, 1000);
    },
    onError: (error: Error) => {
      // Show error notification
      toast.error("Nie udało się dodać przepisu", {
        description: error.message || "Sprawdź połączenie z internetem i spróbuj ponownie.",
        action: {
          label: "Spróbuj ponownie",
          onClick: () => mutation.mutate(mutation.variables!),
        },
      });
      console.error("Recipe creation error:", error);
    },
  });

  // Submit handler
  const onSubmit = (data: RecipeSchemaType) => {
    // Assign sort_order based on array index
    const dataWithSortOrder: RecipeSchemaType = {
      ...data,
      ingredients: data.ingredients.map((ing, index) => ({
        ...ing,
        sort_order: index,
      })),
    };

    mutation.mutate(dataWithSortOrder);
  };

  // Cancel handler with dirty check
  const handleCancel = () => {
    // Check if form has any values (dirty check)
    const hasChanges =
      nameValue.trim() !== "" || instructionsValue.trim() !== "" || fields.some((field) => field.name.trim() !== "");

    if (hasChanges) {
      if (confirm("Czy na pewno chcesz anulować? Niezapisane zmiany zostaną utracone.")) {
        window.history.back();
      }
    } else {
      window.history.back();
    }
  };

  // Watch form values
  const nameValue = watch("name");
  const instructionsValue = watch("instructions");

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="recipe-form bg-white rounded-lg shadow-sm p-6 sm:p-8"
      noValidate
      aria-label="Formularz dodawania przepisu"
    >
      {/* Header with breadcrumbs */}
      <FormHeader />

      {/* Form Fields */}
      <div className="space-y-8">
        {/* Name Input */}
        <Controller
          name="name"
          control={control}
          render={({ field }) => (
            <NameInput value={field.value} onChange={field.onChange} error={errors.name?.message} />
          )}
        />

        {/* Instructions Textarea */}
        <Controller
          name="instructions"
          control={control}
          render={({ field }) => (
            <InstructionsTextarea value={field.value} onChange={field.onChange} error={errors.instructions?.message} />
          )}
        />

        {/* Ingredients List */}
        <IngredientsList
          ingredients={fields}
          onAdd={append}
          onRemove={remove}
          onUpdate={(index, field, value) => {
            const ingredient = fields[index];
            update(index, { ...ingredient, [field]: value });
          }}
          errors={errors.ingredients as any}
        />
      </div>

      {/* Form Actions (sticky bottom) */}
      <FormActions onCancel={handleCancel} isSubmitting={mutation.isPending} isValid={isValid} />
    </form>
  );
}



================================================
FILE: src/components/recipes/RecipeMeta.tsx
================================================
/**
 * Recipe Meta - wyświetla meta informacje o przepisie
 * Pokazuje daty utworzenia i ostatniej edycji
 */
import { format } from "date-fns";
import { pl } from "date-fns/locale";

interface RecipeMetaProps {
  createdAt: string;
  updatedAt: string;
}

/**
 * RecipeMeta
 * Wyświetla daty utworzenia i ostatniej edycji w formacie czytelnym dla użytkownika
 */
export function RecipeMeta({ createdAt, updatedAt }: RecipeMetaProps) {
  return (
    <div className="recipe-meta flex flex-wrap gap-4 text-sm text-gray-600">
      <div>
        <span className="font-medium">Dodano:</span>{" "}
        <time dateTime={createdAt}>{format(new Date(createdAt), "d MMMM yyyy, HH:mm", { locale: pl })}</time>
      </div>

      {updatedAt !== createdAt && (
        <div>
          <span className="font-medium">Ostatnia edycja:</span>{" "}
          <time dateTime={updatedAt}>{format(new Date(updatedAt), "d MMMM yyyy, HH:mm", { locale: pl })}</time>
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipesGrid.tsx
================================================
/**
 * Recipes Grid Component
 * Displays recipes in a responsive grid with infinite scroll
 */
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { RecipeCard } from "./RecipeCard";
import type { RecipeListItemDto } from "@/types";

interface RecipesGridProps {
  recipes: RecipeListItemDto[];
  hasNextPage: boolean;
  isFetchingNextPage: boolean;
  onLoadMore: () => void;
  onPrefetch?: (recipeId: string) => void;
}

/**
 * Recipes Grid Component
 * Responsive grid with infinite scroll using Intersection Observer
 * Fallback to manual "Load More" button if needed
 */
export function RecipesGrid({ recipes, hasNextPage, isFetchingNextPage, onLoadMore, onPrefetch }: RecipesGridProps) {
  // Intersection Observer for infinite scroll
  const { ref: sentinelRef, inView } = useInView({
    threshold: 0,
    triggerOnce: false,
  });

  // Auto-trigger fetchNextPage when sentinel is in viewport
  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      onLoadMore();
    }
  }, [inView, hasNextPage, isFetchingNextPage, onLoadMore]);

  return (
    <div className="recipes-grid">
      {/* Recipes grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {recipes.map((recipe) => (
          <RecipeCard key={recipe.id} recipe={recipe} onPrefetch={onPrefetch} />
        ))}
      </div>

      {/* Infinite scroll sentinel / Load More section */}
      {hasNextPage && (
        <div ref={sentinelRef} className="py-8 flex justify-center">
          {isFetchingNextPage ? (
            // Loading spinner
            <div className="flex items-center gap-2 text-gray-600">
              <Loader2 className="h-5 w-5 animate-spin" />
              <span>Ładowanie...</span>
            </div>
          ) : (
            // Fallback manual button
            <Button onClick={onLoadMore} variant="outline" aria-label="Załaduj więcej przepisów">
              Załaduj więcej
            </Button>
          )}
        </div>
      )}

      {/* Live region for screen readers */}
      <div role="status" aria-live="polite" aria-atomic="true" className="sr-only">
        {isFetchingNextPage && "Ładowanie kolejnych przepisów"}
        {!hasNextPage && recipes.length > 0 && "Załadowano wszystkie przepisy"}
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipesGridSkeleton.tsx
================================================
/**
 * Recipes Grid Skeleton Component
 * Loading placeholder for full recipes grid
 */
import { RecipeCardSkeleton } from "./RecipeCardSkeleton";

/**
 * Recipes Grid Skeleton Component
 * Displays 20 skeleton cards in a responsive grid
 * Used during initial page load before recipes data is fetched
 */
export function RecipesGridSkeleton() {
  return (
    <div className="recipes-grid-skeleton">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {Array.from({ length: 20 }).map((_, index) => (
          <RecipeCardSkeleton key={index} />
        ))}
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipesHeader.tsx
================================================
/**
 * Recipes Header Component
 * Sticky header with search, sort and add recipe controls
 */
import { SearchBar } from "./SearchBar";
import { SortDropdown } from "./SortDropdown";
import { AddRecipeButton } from "./AddRecipeButton";
import type { RecipeSortOption } from "@/types";

interface RecipesHeaderProps {
  search: string;
  sort: RecipeSortOption;
  onSearchChange: (value: string) => void;
  onSortChange: (value: RecipeSortOption) => void;
  recipesCount: number;
}

/**
 * Get proper Polish pluralization for recipes count
 * @param count - Number of recipes
 * @returns Properly pluralized word
 */
function getPluralizedRecipes(count: number): string {
  if (count === 1) {
    return "przepis";
  }
  return "przepisów";
}

/**
 * Recipes Header Component
 * Sticky header containing search bar, sort dropdown and add recipe button
 * On mobile, shows FAB (Floating Action Button) instead of inline button
 */
export function RecipesHeader({ search, sort, onSearchChange, onSortChange, recipesCount }: RecipesHeaderProps) {
  return (
    <>
      <header className="recipes-header sticky top-0 bg-white z-10 border-b shadow-sm">
        <div className="container mx-auto p-4">
          <div className="flex flex-col md:flex-row gap-4 items-start md:items-center justify-between">
            {/* Search bar (full width mobile, max-w-md desktop) */}
            <div className="flex-1 w-full md:max-w-md">
              <SearchBar value={search} onChange={onSearchChange} placeholder="Szukaj przepisu..." />
            </div>

            {/* Right side: count + sort + add button */}
            <div className="flex items-center gap-4 w-full md:w-auto justify-between md:justify-end">
              {/* Recipes count (only if > 0) */}
              {recipesCount > 0 && (
                <span className="text-sm text-gray-600 whitespace-nowrap">
                  {recipesCount} {getPluralizedRecipes(recipesCount)}
                </span>
              )}

              {/* Sort dropdown */}
              <SortDropdown value={sort} onChange={onSortChange} />

              {/* Add recipe button (desktop only) */}
              <AddRecipeButton className="hidden md:inline-flex" />
            </div>
          </div>
        </div>
      </header>

      {/* Floating Action Button (mobile only) */}
      <AddRecipeButton variant="fab" className="md:hidden fixed bottom-6 right-6 z-20" />
    </>
  );
}



================================================
FILE: src/components/recipes/RecipesListView.tsx
================================================
/**
 * Recipes List View - Main Container Component
 * Orchestrates the entire recipes list view with search, sort and infinite scroll
 */
import { useRecipesList } from "@/components/hooks/useRecipesList";
import { RecipesHeader } from "./RecipesHeader";
import { RecipesGrid } from "./RecipesGrid";
import { RecipesGridSkeleton } from "./RecipesGridSkeleton";
import { EmptyState } from "./EmptyState";
import { ErrorMessage } from "./ErrorMessage";

/**
 * Main Recipes List View Component
 * Manages state and orchestrates all child components
 * Handles loading, error and empty states
 */
export function RecipesListView() {
  const {
    search,
    sort,
    recipes,
    totalRecipes,
    hasNextPage,
    isLoading,
    isFetchingNextPage,
    error,
    handleSearchChange,
    handleSortChange,
    fetchNextPage,
    refetch,
    prefetchRecipe,
  } = useRecipesList();

  // === Loading state (first load) ===
  if (isLoading && recipes.length === 0) {
    return (
      <>
        <RecipesHeader
          search={search}
          sort={sort}
          onSearchChange={handleSearchChange}
          onSortChange={handleSortChange}
          recipesCount={totalRecipes}
        />
        <div className="container mx-auto p-4">
          <RecipesGridSkeleton />
        </div>
      </>
    );
  }

  // === Error state (first load failed) ===
  if (error && recipes.length === 0) {
    return (
      <>
        <RecipesHeader
          search={search}
          sort={sort}
          onSearchChange={handleSearchChange}
          onSortChange={handleSortChange}
          recipesCount={totalRecipes}
        />
        <div className="container mx-auto p-4">
          <ErrorMessage error={error} onRetry={refetch} />
        </div>
      </>
    );
  }

  // === Empty state (no recipes or no search results) ===
  if (recipes.length === 0) {
    return (
      <>
        <RecipesHeader
          search={search}
          sort={sort}
          onSearchChange={handleSearchChange}
          onSortChange={handleSortChange}
          recipesCount={totalRecipes}
        />
        <div className="container mx-auto p-4">
          <EmptyState hasSearch={!!search} search={search} onClearSearch={() => handleSearchChange("")} />
        </div>
      </>
    );
  }

  // === Success state (recipes loaded) ===
  return (
    <div className="recipes-list-view">
      <RecipesHeader
        search={search}
        sort={sort}
        onSearchChange={handleSearchChange}
        onSortChange={handleSortChange}
        recipesCount={totalRecipes}
      />
      <div className="container mx-auto p-4">
        <RecipesGrid
          recipes={recipes}
          hasNextPage={hasNextPage}
          isFetchingNextPage={isFetchingNextPage}
          onLoadMore={fetchNextPage}
          onPrefetch={prefetchRecipe}
        />
      </div>
    </div>
  );
}



================================================
FILE: src/components/recipes/RecipesListViewWrapper.tsx
================================================
/**
 * Recipes List View Wrapper
 * Wraps RecipesListView with QueryProvider to ensure proper React Query context
 * This is necessary because Astro's client:load creates separate islands
 */
import { QueryProvider } from "@/components/providers/QueryProvider";
import { RecipesListView } from "./RecipesListView";

/**
 * Wrapper component that provides QueryClient context to RecipesListView
 * Must be used as a single client:load component in Astro
 */
export function RecipesListViewWrapper() {
  return (
    <QueryProvider>
      <RecipesListView />
    </QueryProvider>
  );
}


================================================
FILE: src/components/recipes/SearchBar.tsx
================================================
/**
 * Search Bar Component for Recipes List
 * Input field with search icon, clear button and accessibility features
 */
import { useState, useCallback } from "react";
import { Search, X } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

/**
 * Search Bar Component
 * Features: search icon, clear button, Escape key support, live region
 */
export function SearchBar({ value, onChange, placeholder = "Szukaj przepisu..." }: SearchBarProps) {
  const [isSearching] = useState(false);

  /**
   * Handle clear button click
   * Clears search value and triggers onChange
   */
  const handleClear = useCallback(() => {
    onChange("");
  }, [onChange]);

  /**
   * Handle Escape key press
   * Clears search value when Escape is pressed
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === "Escape") {
        onChange("");
      }
    },
    [onChange]
  );

  return (
    <>
      <div className="relative">
        {/* Search icon (left) */}
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none" />

        {/* Search input */}
        <Input
          type="search"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          aria-label="Wyszukaj przepisy"
          className="pl-10 pr-10"
          maxLength={100}
        />

        {/* Clear button (right, conditional) */}
        {value && (
          <Button
            variant="ghost"
            size="icon"
            onClick={handleClear}
            className="absolute right-2 top-1/2 -translate-y-1/2 h-7 w-7"
            aria-label="Wyczyść wyszukiwanie"
            type="button"
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {/* Live region for screen readers */}
      <div role="status" aria-live="polite" className="sr-only">
        {isSearching && "Wyszukiwanie..."}
      </div>
    </>
  );
}



================================================
FILE: src/components/recipes/SortDropdown.tsx
================================================
/**
 * Sort Dropdown Component for Recipes List
 * Allows users to sort recipes by different criteria
 */
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import type { RecipeSortOption } from "@/types";
import { RECIPE_SORT_LABELS } from "@/types";

interface SortDropdownProps {
  value: RecipeSortOption;
  onChange: (value: RecipeSortOption) => void;
}

/**
 * Sort Dropdown Component
 * Select component with sort options for recipes list
 */
export function SortDropdown({ value, onChange }: SortDropdownProps) {
  return (
    <div className="sort-dropdown">
      <Label htmlFor="sort-select" className="sr-only">
        Sortuj przepisy
      </Label>

      <Select value={value} onValueChange={onChange}>
        <SelectTrigger id="sort-select" className="w-[200px]" aria-label="Sortuj przepisy">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="created_desc">{RECIPE_SORT_LABELS.created_desc}</SelectItem>
          <SelectItem value="created_asc">{RECIPE_SORT_LABELS.created_asc}</SelectItem>
          <SelectItem value="name_asc">{RECIPE_SORT_LABELS.name_asc}</SelectItem>
          <SelectItem value="name_desc">{RECIPE_SORT_LABELS.name_desc}</SelectItem>
        </SelectContent>
      </Select>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/CategoriesAccordion.tsx
================================================
/**
 * CategoriesAccordion - accordion z kategoriami składników
 * Tylko niepuste kategorie są wyświetlane
 */
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { IngredientItem } from "./IngredientItem";
import { CATEGORY_ORDER } from "@/types";
import type { ShoppingListItemDto } from "@/types";

interface CategoriesAccordionProps {
  items: ShoppingListItemDto[];
  onToggleItem: (itemId: string, currentChecked: boolean) => void;
}

export function CategoriesAccordion({ items, onToggleItem }: CategoriesAccordionProps) {
  return (
    <Accordion type="multiple" defaultValue={CATEGORY_ORDER} className="space-y-2">
      {CATEGORY_ORDER.map((category) => {
        const categoryItems = items
          .filter((item) => item.category === category)
          .sort((a, b) => a.sort_order - b.sort_order);

        if (categoryItems.length === 0) return null;

        return (
          <AccordionItem key={category} value={category}>
            <AccordionTrigger className="p-4 bg-gray-50 rounded-lg hover:bg-gray-100">
              <div className="flex items-center gap-2">
                <span className="font-semibold text-lg">{category}</span>
                <Badge variant="secondary">{categoryItems.length}</Badge>
              </div>
            </AccordionTrigger>

            <AccordionContent className="pt-4 space-y-2">
              {categoryItems.map((item) => (
                <IngredientItem key={item.id} item={item} onToggle={() => onToggleItem(item.id, item.is_checked)} />
              ))}
            </AccordionContent>
          </AccordionItem>
        );
      })}
    </Accordion>
  );
}



================================================
FILE: src/components/shopping-lists/DeleteConfirmationDialog.tsx
================================================
/**
 * DeleteConfirmationDialog component
 * Modal confirming shopping list deletion
 */

import { Loader2 } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

interface DeleteConfirmationDialogProps {
  isOpen: boolean;
  listId: string | null;
  listName: string | null;
  isDeleting: boolean;
  onClose: () => void;
  onConfirm: () => void;
}

export function DeleteConfirmationDialog({
  isOpen,
  listName,
  isDeleting,
  onClose,
  onConfirm,
}: DeleteConfirmationDialogProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Usuń listę zakupów?</DialogTitle>
          <DialogDescription>
            Czy na pewno chcesz usunąć listę &quot;{listName}&quot;? Ta operacja jest nieodwracalna.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter>
          <Button variant="ghost" onClick={onClose} disabled={isDeleting}>
            Anuluj
          </Button>

          <Button variant="destructive" onClick={onConfirm} disabled={isDeleting}>
            {isDeleting ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Usuwanie...
              </>
            ) : (
              "Usuń listę"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: src/components/shopping-lists/EmptyState.tsx
================================================
/**
 * EmptyState component
 * Displayed when user has no shopping lists
 */

import { ShoppingCart, Plus } from "lucide-react";
import { Button } from "@/components/ui/button";

export function EmptyState() {
  return (
    <div className="empty-state py-16 text-center">
      <div className="max-w-md mx-auto">
        <ShoppingCart className="h-16 w-16 mx-auto text-gray-400 mb-4" />
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">Nie masz jeszcze list zakupów</h2>
        <p className="text-gray-600 mb-6">Wygeneruj pierwszą listę z kalendarza tygodniowego lub wybranych przepisów</p>
        <Button asChild size="lg">
          <a href="/shopping-lists/generate">
            <Plus className="h-4 w-4 mr-2" />
            Generuj pierwszą listę
          </a>
        </Button>
      </div>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/IngredientItem.tsx
================================================
/**
 * IngredientItem - pojedynczy składnik z checkbox i tekstem
 * Checked state: line-through + muted color
 */
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import type { ShoppingListItemDto } from "@/types";

interface IngredientItemProps {
  item: ShoppingListItemDto;
  onToggle: () => void;
}

export function IngredientItem({ item, onToggle }: IngredientItemProps) {
  return (
    <div
      className={cn(
        "ingredient-item flex items-center gap-3 p-3 border rounded-lg transition",
        item.is_checked && "bg-gray-50"
      )}
    >
      <Checkbox
        id={`item-${item.id}`}
        checked={item.is_checked}
        onCheckedChange={onToggle}
        className="h-6 w-6"
        aria-label={`Zaznacz składnik: ${item.ingredient_name}`}
      />

      <Label
        htmlFor={`item-${item.id}`}
        className={cn("flex-1 cursor-pointer", item.is_checked && "line-through text-gray-500")}
      >
        <span className="flex items-baseline gap-2">
          {item.quantity && <strong className="text-gray-900">{item.quantity}</strong>}
          {item.unit && <span className="text-gray-600">{item.unit}</span>}
          <span>{item.ingredient_name}</span>
        </span>
      </Label>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ListMeta.tsx
================================================
/**
 * ListMeta - metadane listy zakupów (data utworzenia, zakres tygodnia)
 */
import { format } from "date-fns";
import { pl } from "date-fns/locale";
import { Clock, Calendar } from "lucide-react";
import { formatWeekRange } from "@/lib/utils/date";

interface ListMetaProps {
  createdAt: string;
  weekStartDate: string | null;
}

export function ListMeta({ createdAt, weekStartDate }: ListMetaProps) {
  return (
    <div className="list-meta flex flex-wrap gap-4 text-sm text-gray-600">
      <div className="flex items-center gap-1">
        <Clock className="h-3 w-3" />
        <span>Utworzono: {format(new Date(createdAt), "d MMMM yyyy, HH:mm", { locale: pl })}</span>
      </div>

      {weekStartDate && (
        <div className="flex items-center gap-1">
          <Calendar className="h-3 w-3" />
          <span>{formatWeekRange(weekStartDate)}</span>
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/PDFPreviewModal.tsx
================================================
/**
 * PDFPreviewModal - modal z preview wygenerowanego PDF
 * Lazy loaded z iframe preview przed pobraniem
 */
import React from "react";
import { pdf } from "@react-pdf/renderer";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Download, Loader2 } from "lucide-react";
import { toast } from "sonner";
import { ShoppingListPDFDocument } from "@/lib/pdf-export/ShoppingListPDFDocument";
import { generateFilename } from "@/lib/utils/export";
import type { ShoppingListResponseDto } from "@/types";

interface PDFPreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  list: ShoppingListResponseDto;
}

export function PDFPreviewModal({ isOpen, onClose, list }: PDFPreviewModalProps) {
  const [isGeneratingPDF, setIsGeneratingPDF] = React.useState(false);
  const [pdfBlobUrl, setPDFBlobUrl] = React.useState<string | null>(null);

  // Generate PDF when modal opens
  React.useEffect(() => {
    if (!isOpen) {
      setPDFBlobUrl(null);
      return;
    }

    setIsGeneratingPDF(true);

    (async () => {
      try {
        const doc = <ShoppingListPDFDocument list={list} />;
        const blob = await pdf(doc).toBlob();
        const url = URL.createObjectURL(blob);

        setPDFBlobUrl(url);
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error("Error generating PDF:", error);
        toast.error("Nie udało się wygenerować PDF");
        onClose();
      } finally {
        setIsGeneratingPDF(false);
      }
    })();
  }, [isOpen, list, onClose]);

  // Cleanup blob URL when it changes or on unmount
  React.useEffect(() => {
    return () => {
      if (pdfBlobUrl) {
        URL.revokeObjectURL(pdfBlobUrl);
      }
    };
  }, [pdfBlobUrl]);

  // Handle download
  const handleDownload = () => {
    if (!pdfBlobUrl) return;

    const filename = generateFilename(list.name, "pdf");
    const link = document.createElement("a");
    link.href = pdfBlobUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    toast.success("PDF pobrano pomyślnie");
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl h-[90vh]">
        <DialogHeader>
          <DialogTitle>Podgląd PDF</DialogTitle>
          <DialogDescription>Sprawdź PDF przed pobraniem</DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-hidden">
          {isGeneratingPDF ? (
            <div className="flex items-center justify-center h-full">
              <Loader2 className="h-8 w-8 mr-3 animate-spin" />
              <span>Generuję PDF...</span>
            </div>
          ) : pdfBlobUrl ? (
            <iframe src={pdfBlobUrl} className="w-full h-full border-0" title="PDF Preview" />
          ) : null}
        </div>

        <DialogFooter>
          <Button variant="ghost" onClick={onClose}>
            Anuluj
          </Button>
          <Button onClick={handleDownload} disabled={!pdfBlobUrl || isGeneratingPDF}>
            <Download className="h-4 w-4 mr-2" />
            Pobierz PDF
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListCard.tsx
================================================
/**
 * ShoppingListCard component
 * Card for a single shopping list showing name, metadata, badge with item count, and delete button
 */

import { Clock, Calendar, ShoppingCart, Trash2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { formatRelativeTime, formatWeekRange } from "@/lib/utils/date";
import { truncate } from "@/lib/utils/text";
import type { ShoppingListListItemDto } from "@/types";

interface ShoppingListCardProps {
  list: ShoppingListListItemDto;
  onDelete: () => void;
}

export function ShoppingListCard({ list, onDelete }: ShoppingListCardProps) {
  return (
    <article className="shopping-list-card relative">
      <a href={`/shopping-lists/${list.id}`} className="block">
        <div className="border rounded-lg p-6 hover:shadow-lg transition-shadow bg-white">
          <h3 className="text-lg font-semibold text-gray-900 mb-2 pr-10" title={list.name}>
            {truncate(list.name, 60)}
          </h3>

          <div className="flex flex-wrap items-center gap-3 text-sm text-gray-600">
            <time dateTime={list.created_at} className="flex items-center gap-1">
              <Clock className="h-3 w-3" />
              {formatRelativeTime(list.created_at)}
            </time>

            {list.week_start_date && (
              <span className="flex items-center gap-1">
                <Calendar className="h-3 w-3" />
                {formatWeekRange(list.week_start_date)}
              </span>
            )}

            <Badge variant="secondary" className="flex items-center gap-1">
              <ShoppingCart className="h-3 w-3" />
              {list.items_count} {list.items_count === 1 ? "składnik" : "składników"}
            </Badge>
          </div>
        </div>
      </a>

      <Button
        variant="ghost"
        size="icon"
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          onDelete();
        }}
        className="absolute top-4 right-4"
        aria-label={`Usuń listę ${list.name}`}
      >
        <Trash2 className="h-4 w-4 text-red-600" />
      </Button>
    </article>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListDetailsContent.tsx
================================================
/**
 * ShoppingListDetailsContent - główna zawartość z tytułem, meta informacjami oraz accordion
 */
import { ListMeta } from "./ListMeta";
import { CategoriesAccordion } from "./CategoriesAccordion";
import type { ShoppingListResponseDto } from "@/types";

interface ShoppingListDetailsContentProps {
  list: ShoppingListResponseDto;
  onToggleItem: (itemId: string, currentChecked: boolean) => void;
}

export function ShoppingListDetailsContent({ list, onToggleItem }: ShoppingListDetailsContentProps) {
  return (
    <div className="shopping-list-details-content container mx-auto max-w-4xl p-4">
      <h1 className="text-4xl font-bold text-gray-900 mb-2">{list.name}</h1>

      <ListMeta createdAt={list.created_at} weekStartDate={list.week_start_date} />

      <div className="mt-8">
        <CategoriesAccordion items={list.items} onToggleItem={onToggleItem} />
      </div>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListDetailsSkeleton.tsx
================================================
/**
 * ShoppingListDetailsSkeleton - skeleton loader dla widoku szczegółów listy
 */
import { Skeleton } from "@/components/ui/skeleton";

export function ShoppingListDetailsSkeleton() {
  return (
    <div className="shopping-list-details-skeleton">
      {/* Header skeleton */}
      <header className="sticky top-0 bg-white z-10 border-b shadow-sm">
        <div className="container mx-auto p-4">
          {/* Breadcrumbs skeleton */}
          <div className="flex items-center gap-2 mb-4">
            <Skeleton className="h-4 w-32" />
            <Skeleton className="h-4 w-4" />
            <Skeleton className="h-4 w-48" />
          </div>

          {/* Buttons skeleton */}
          <div className="flex flex-wrap gap-3">
            <Skeleton className="h-10 w-36" />
            <Skeleton className="h-10 w-36" />
            <Skeleton className="h-10 w-32" />
            <Skeleton className="h-10 w-28" />
          </div>
        </div>
      </header>

      {/* Content skeleton */}
      <div className="container mx-auto max-w-4xl p-4">
        {/* Title skeleton */}
        <Skeleton className="h-10 w-96 mb-2" />

        {/* Meta skeleton */}
        <div className="flex flex-wrap gap-4 mb-8">
          <Skeleton className="h-4 w-48" />
          <Skeleton className="h-4 w-40" />
        </div>

        {/* Categories skeleton */}
        <div className="space-y-2">
          {[1, 2, 3].map((i) => (
            <div key={i} className="border rounded-lg">
              <Skeleton className="h-14 w-full rounded-lg" />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListDetailsView.tsx
================================================
/**
 * ShoppingListDetailsView - główny kontener zarządzający fetchem, mutacjami i modali
 */
import React from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { ShoppingListHeader } from "./ShoppingListHeader";
import { ShoppingListDetailsContent } from "./ShoppingListDetailsContent";
import { ShoppingListDetailsSkeleton } from "./ShoppingListDetailsSkeleton";
import { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
import { PDFPreviewModal } from "./PDFPreviewModal";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { generateShoppingListTXT, downloadTXT, generateFilename } from "@/lib/utils/export";
import type { ShoppingListResponseDto } from "@/types";

interface ShoppingListDetailsViewProps {
  listId: string;
}

export function ShoppingListDetailsView({ listId }: ShoppingListDetailsViewProps) {
  const queryClient = useQueryClient();

  // Local state for modals
  const [pdfModalOpen, setPDFModalOpen] = React.useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = React.useState(false);

  // Fetch shopping list with items
  const {
    data: shoppingList,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["shopping-list", listId],
    queryFn: async () => {
      const response = await fetch(`/api/shopping-lists/${listId}`);

      if (response.status === 404) {
        throw new Error("Shopping list not found");
      }

      if (!response.ok) {
        throw new Error("Failed to fetch shopping list");
      }

      return response.json() as Promise<ShoppingListResponseDto>;
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
  });

  // Toggle item mutation with optimistic update
  const toggleItemMutation = useMutation({
    mutationFn: async ({ itemId, isChecked }: { itemId: string; isChecked: boolean }) => {
      const response = await fetch(`/api/shopping-lists/${listId}/items/${itemId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ is_checked: isChecked }),
      });

      if (!response.ok) {
        throw new Error("Failed to update item");
      }

      return response.json();
    },
    onMutate: async ({ itemId, isChecked }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["shopping-list", listId] });

      // Snapshot previous value
      const previous = queryClient.getQueryData<ShoppingListResponseDto>(["shopping-list", listId]);

      // Optimistically update
      queryClient.setQueryData<ShoppingListResponseDto>(["shopping-list", listId], (old) => {
        if (!old) return old;

        return {
          ...old,
          items: old.items.map((item) => (item.id === itemId ? { ...item, is_checked: isChecked } : item)),
        };
      });

      return { previous };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previous) {
        queryClient.setQueryData(["shopping-list", listId], context.previous);
      }

      toast.error("Nie udało się zaktualizować składnika");
    },
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ["shopping-list", listId] });
    },
  });

  // Handler for toggle item
  const handleToggleItem = (itemId: string, currentChecked: boolean) => {
    toggleItemMutation.mutate({ itemId, isChecked: !currentChecked });
  };

  // Delete mutation
  const deleteMutation = useMutation({
    mutationFn: async () => {
      const response = await fetch(`/api/shopping-lists/${listId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete shopping list");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["shopping-lists"] });
      toast.success("Lista zakupów usunięta");
    },
    onError: (error: Error) => {
      toast.error(error.message || "Nie udało się usunąć listy");
    },
  });

  // Handle navigation after successful delete
  React.useEffect(() => {
    if (deleteMutation.isSuccess) {
      window.location.href = "/shopping-lists";
    }
  }, [deleteMutation.isSuccess]);

  // Handler for delete
  const handleDelete = () => {
    deleteMutation.mutate();
  };

  // Handler for TXT export
  const handleExportTXT = () => {
    if (!shoppingList) return;

    try {
      const content = generateShoppingListTXT(shoppingList);
      const filename = generateFilename(shoppingList.name, "txt");
      downloadTXT(content, filename);
      toast.success("Lista wyeksportowana do TXT");
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("Error exporting TXT:", error);
      toast.error("Nie udało się wyeksportować listy");
    }
  };

  // Loading state
  if (isLoading) {
    return <ShoppingListDetailsSkeleton />;
  }

  // Error state
  if (error) {
    return (
      <div className="container mx-auto max-w-4xl p-4">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Błąd</AlertTitle>
          <AlertDescription>
            {error instanceof Error && error.message === "Shopping list not found"
              ? "Lista zakupów nie została znaleziona"
              : "Nie udało się załadować listy zakupów"}
          </AlertDescription>
        </Alert>
        <Button asChild className="mt-4">
          <a href="/shopping-lists">Powrót do list zakupów</a>
        </Button>
      </div>
    );
  }

  // No data state (shouldn't happen, but defensive coding)
  if (!shoppingList) {
    return (
      <div className="container mx-auto max-w-4xl p-4">
        <Alert>
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Brak danych</AlertTitle>
          <AlertDescription>Lista zakupów nie została znaleziona</AlertDescription>
        </Alert>
        <Button asChild className="mt-4">
          <a href="/shopping-lists">Powrót do list zakupów</a>
        </Button>
      </div>
    );
  }

  // Success state
  return (
    <div className="shopping-list-details-view">
      <ShoppingListHeader
        list={shoppingList}
        onExportPDF={() => setPDFModalOpen(true)}
        onExportTXT={handleExportTXT}
        onDelete={() => setDeleteDialogOpen(true)}
      />

      <ShoppingListDetailsContent list={shoppingList} onToggleItem={handleToggleItem} />

      {/* Delete confirmation dialog */}
      <DeleteConfirmationDialog
        isOpen={deleteDialogOpen}
        listId={shoppingList.id}
        listName={shoppingList.name}
        isDeleting={deleteMutation.isPending}
        onClose={() => setDeleteDialogOpen(false)}
        onConfirm={handleDelete}
      />

      {/* PDF preview modal */}
      {pdfModalOpen && (
        <PDFPreviewModal isOpen={pdfModalOpen} onClose={() => setPDFModalOpen(false)} list={shoppingList} />
      )}
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListHeader.tsx
================================================
/**
 * ShoppingListHeader - sticky header z breadcrumbs i przyciskami akcji
 */
import { Button } from "@/components/ui/button";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { FileText, Download, Trash2, ArrowLeft } from "lucide-react";
import type { ShoppingListResponseDto } from "@/types";

interface ShoppingListHeaderProps {
  list: ShoppingListResponseDto;
  onExportPDF: () => void;
  onExportTXT: () => void;
  onDelete: () => void;
}

export function ShoppingListHeader({ list, onExportPDF, onExportTXT, onDelete }: ShoppingListHeaderProps) {
  // Truncate list name for breadcrumbs if too long
  const truncateName = (name: string, maxLength: number) => {
    if (name.length <= maxLength) return name;
    return name.slice(0, maxLength) + "...";
  };

  return (
    <header className="shopping-list-header sticky top-0 bg-white z-10 border-b shadow-sm">
      <div className="container mx-auto p-4">
        {/* Breadcrumbs */}
        <Breadcrumb>
          <BreadcrumbList>
            <BreadcrumbItem>
              <BreadcrumbLink href="/shopping-lists">Listy zakupów</BreadcrumbLink>
            </BreadcrumbItem>
            <BreadcrumbSeparator />
            <BreadcrumbItem>
              <BreadcrumbPage>{truncateName(list.name, 40)}</BreadcrumbPage>
            </BreadcrumbItem>
          </BreadcrumbList>
        </Breadcrumb>

        {/* Action buttons */}
        <div className="flex flex-wrap gap-3 mt-4">
          <Button onClick={onExportPDF} variant="default">
            <FileText className="h-4 w-4 mr-2" />
            Eksportuj PDF
          </Button>

          <Button onClick={onExportTXT} variant="outline">
            <Download className="h-4 w-4 mr-2" />
            Eksportuj TXT
          </Button>

          <Button onClick={onDelete} variant="destructive">
            <Trash2 className="h-4 w-4 mr-2" />
            Usuń listę
          </Button>

          <Button asChild variant="ghost">
            <a href="/shopping-lists">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Powrót
            </a>
          </Button>
        </div>
      </div>
    </header>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListsGrid.tsx
================================================
/**
 * ShoppingListsGrid component
 * Grid layout with shopping list cards. Responsive (2 columns desktop, 1 mobile).
 * Handles pagination with manual "Load more" button.
 */

import { ChevronDown, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { ShoppingListCard } from "./ShoppingListCard";
import type { ShoppingListListItemDto } from "@/types";

interface ShoppingListsGridProps {
  shoppingLists: ShoppingListListItemDto[];
  onDelete: (id: string, name: string) => void;
  hasNextPage: boolean;
  isFetchingNextPage: boolean;
  onLoadMore: () => void;
}

export function ShoppingListsGrid({
  shoppingLists,
  onDelete,
  hasNextPage,
  isFetchingNextPage,
  onLoadMore,
}: ShoppingListsGridProps) {
  return (
    <div className="shopping-lists-grid container mx-auto p-4">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {shoppingLists.map((list) => (
          <ShoppingListCard key={list.id} list={list} onDelete={() => onDelete(list.id, list.name)} />
        ))}
      </div>

      {hasNextPage && (
        <div className="mt-8 flex justify-center">
          <Button onClick={onLoadMore} disabled={isFetchingNextPage} variant="outline" size="lg">
            {isFetchingNextPage ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Ładowanie...
              </>
            ) : (
              <>
                Załaduj więcej
                <ChevronDown className="h-4 w-4 ml-2" />
              </>
            )}
          </Button>
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListsGridSkeleton.tsx
================================================
/**
 * ShoppingListsGridSkeleton component
 * Skeleton loader displayed while shopping lists are loading
 */

import { Skeleton } from "@/components/ui/skeleton";

export function ShoppingListsGridSkeleton() {
  return (
    <div className="shopping-lists-grid-skeleton container mx-auto p-4">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {Array.from({ length: 6 }).map((_, index) => (
          <div key={index} className="border rounded-lg p-6 bg-white">
            <Skeleton className="h-6 w-3/4 mb-2" />
            <div className="flex gap-3">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-4 w-32" />
              <Skeleton className="h-5 w-20" />
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListsHeader.tsx
================================================
/**
 * ShoppingListsHeader component
 * Sticky header with breadcrumbs and "Generate new list" button
 */

import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Breadcrumb, BreadcrumbItem, BreadcrumbList, BreadcrumbPage } from "@/components/ui/breadcrumb";

export function ShoppingListsHeader() {
  return (
    <header className="shopping-lists-header sticky top-0 bg-white z-10 border-b shadow-sm">
      <div className="container mx-auto p-4">
        <Breadcrumb>
          <BreadcrumbList>
            <BreadcrumbItem>
              <BreadcrumbPage>Listy zakupów</BreadcrumbPage>
            </BreadcrumbItem>
          </BreadcrumbList>
        </Breadcrumb>

        <div className="flex items-center justify-between mt-4">
          <h1 className="text-3xl font-bold text-gray-900">Listy zakupów</h1>

          <Button asChild size="lg">
            <a href="/shopping-lists/generate">
              <Plus className="h-4 w-4 mr-2" />
              Generuj nową listę
            </a>
          </Button>
        </div>
      </div>
    </header>
  );
}



================================================
FILE: src/components/shopping-lists/ShoppingListsHistoryView.tsx
================================================
/**
 * ShoppingListsHistoryView - Main container
 * Manages fetching shopping lists, delete dialog state, and pagination
 */

import React from "react";
import { useInfiniteQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { ShoppingListsHeader } from "./ShoppingListsHeader";
import { ShoppingListsGrid } from "./ShoppingListsGrid";
import { EmptyState } from "./EmptyState";
import { ShoppingListsGridSkeleton } from "./ShoppingListsGridSkeleton";
import { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { PaginatedResponse, ShoppingListListItemDto } from "@/types";

interface DeleteDialogState {
  isOpen: boolean;
  listId: string | null;
  listName: string | null;
}

interface ShoppingListsPageResponse {
  data: ShoppingListListItemDto[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    total_pages: number;
  };
  nextPage: number | undefined;
}

export function ShoppingListsHistoryView() {
  const queryClient = useQueryClient();
  const [deleteDialog, setDeleteDialog] = React.useState<DeleteDialogState>({
    isOpen: false,
    listId: null,
    listName: null,
  });

  // Infinite query for shopping lists
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, error } = useInfiniteQuery({
    queryKey: ["shopping-lists", "list"],
    queryFn: async ({ pageParam = 1 }) => {
      const response = await fetch(`/api/shopping-lists?page=${pageParam}&limit=20`);

      if (!response.ok) {
        throw new Error("Failed to fetch shopping lists");
      }

      const result: PaginatedResponse<ShoppingListListItemDto> = await response.json();

      return {
        data: result.data,
        pagination: result.pagination,
        nextPage: result.pagination.page < result.pagination.total_pages ? result.pagination.page + 1 : undefined,
      } as ShoppingListsPageResponse;
    },
    getNextPageParam: (lastPage) => lastPage.nextPage,
    staleTime: 2 * 60 * 1000, // 2 minutes
    initialPageParam: 1,
  });

  // Flatten pages
  const shoppingLists = React.useMemo(() => data?.pages.flatMap((page) => page.data) ?? [], [data]);

  // Delete mutation
  const deleteMutation = useMutation({
    mutationFn: async (listId: string) => {
      const response = await fetch(`/api/shopping-lists/${listId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete shopping list");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["shopping-lists"] });
      toast.success("Lista usunięta");
      closeDeleteDialog();
    },
    onError: (error: Error) => {
      toast.error(error.message || "Nie udało się usunąć listy");
    },
  });

  const openDeleteDialog = React.useCallback((listId: string, listName: string) => {
    setDeleteDialog({ isOpen: true, listId, listName });
  }, []);

  const closeDeleteDialog = React.useCallback(() => {
    setDeleteDialog({ isOpen: false, listId: null, listName: null });
  }, []);

  const handleDelete = React.useCallback(() => {
    if (deleteDialog.listId) {
      deleteMutation.mutate(deleteDialog.listId);
    }
  }, [deleteDialog.listId, deleteMutation]);

  return (
    <div className="shopping-lists-history-view">
      <ShoppingListsHeader />

      {isLoading && <ShoppingListsGridSkeleton />}

      {error && (
        <div className="container mx-auto p-4">
          <Alert variant="destructive">
            <AlertDescription>Nie udało się załadować list zakupów. Spróbuj odświeżyć stronę.</AlertDescription>
          </Alert>
        </div>
      )}

      {!isLoading && !error && shoppingLists.length === 0 && <EmptyState />}

      {!isLoading && !error && shoppingLists.length > 0 && (
        <ShoppingListsGrid
          shoppingLists={shoppingLists}
          onDelete={openDeleteDialog}
          hasNextPage={hasNextPage ?? false}
          isFetchingNextPage={isFetchingNextPage}
          onLoadMore={fetchNextPage}
        />
      )}

      <DeleteConfirmationDialog
        isOpen={deleteDialog.isOpen}
        listId={deleteDialog.listId}
        listName={deleteDialog.listName}
        isDeleting={deleteMutation.isPending}
        onClose={closeDeleteDialog}
        onConfirm={handleDelete}
      />
    </div>
  );
}



================================================
FILE: src/components/ui/accordion.tsx
================================================
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDownIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Accordion({ ...props }: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />;
}

function AccordionItem({ className, ...props }: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  );
}

function AccordionTrigger({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  );
}

function AccordionContent({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  );
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };



================================================
FILE: src/components/ui/alert.tsx
================================================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

function Alert({ className, variant, ...props }: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return <div data-slot="alert" role="alert" className={cn(alertVariants({ variant }), className)} {...props} />;
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)}
      {...props}
    />
  );
}

function AlertDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  );
}

export { Alert, AlertTitle, AlertDescription };



================================================
FILE: src/components/ui/badge.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> & VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span";

  return <Comp data-slot="badge" className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };



================================================
FILE: src/components/ui/breadcrumb.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />;
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  );
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return <li data-slot="breadcrumb-item" className={cn("inline-flex items-center gap-1.5", className)} {...props} />;
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp data-slot="breadcrumb-link" className={cn("hover:text-foreground transition-colors", className)} {...props} />
  );
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  );
}

function BreadcrumbSeparator({ children, className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  );
}

function BreadcrumbEllipsis({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  );
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} />;
}

export { Button, buttonVariants };



================================================
FILE: src/components/ui/checkbox.tsx
================================================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Checkbox({ className, ...props }: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };



================================================
FILE: src/components/ui/collapsible.tsx
================================================
"use client";

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

function Collapsible({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}

function CollapsibleTrigger({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return <CollapsiblePrimitive.CollapsibleTrigger data-slot="collapsible-trigger" {...props} />;
}

function CollapsibleContent({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return <CollapsiblePrimitive.CollapsibleContent data-slot="collapsible-content" {...props} />;
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent };



================================================
FILE: src/components/ui/dialog.tsx
================================================
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({ ...props }: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean;
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
      {...props}
    />
  );
}

function DialogTitle({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};



================================================
FILE: src/components/ui/input.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  );
}

export { Input };



================================================
FILE: src/components/ui/label.tsx
================================================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "@/lib/utils";

function Label({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  );
}

export { Label };



================================================
FILE: src/components/ui/progress.tsx
================================================
import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

function Progress({ className, value, ...props }: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn("bg-primary/20 relative h-2 w-full overflow-hidden rounded-full", className)}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  );
}

export { Progress };



================================================
FILE: src/components/ui/radio-group.tsx
================================================
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { CircleIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function RadioGroup({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return <RadioGroupPrimitive.Root data-slot="radio-group" className={cn("grid gap-3", className)} {...props} />;
}

function RadioGroupItem({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };



================================================
FILE: src/components/ui/scroll-area.tsx
================================================
"use client";

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

function ScrollArea({ className, children, ...props }: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn("relative", className)} {...props}>
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}

export { ScrollArea, ScrollBar };



================================================
FILE: src/components/ui/select.tsx
================================================
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({ ...props }: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  );
}

function SelectItem({ className, children, ...props }: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function SelectScrollUpButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};



================================================
FILE: src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="skeleton" className={cn("bg-accent animate-pulse rounded-md", className)} {...props} />;
}

export { Skeleton };



================================================
FILE: src/components/ui/textarea.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  );
}

export { Textarea };



================================================
FILE: src/components/ui/toaster.tsx
================================================
/**
 * Toaster Component
 * Global toast notification container using Sonner
 */
import { Toaster as SonnerToaster } from "sonner";

/**
 * Toaster Component
 * Should be placed at the root layout level
 */
export function Toaster() {
  return (
    <SonnerToaster
      position="top-right"
      richColors
      closeButton
      toastOptions={{
        style: {
          fontFamily: "system-ui, -apple-system, sans-serif",
        },
        className: "toast",
        duration: 5000,
      }}
    />
  );
}



================================================
FILE: src/components/wizard/CalendarSelector.tsx
================================================
import React from "react";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import type { CalendarSelectionDto, MealPlanAssignmentDto, MealType } from "@/types";
import { MEAL_TYPES, MEAL_TYPE_LABELS } from "@/types";
import { cn } from "@/lib/utils";

interface CalendarSelectorProps {
  assignments: MealPlanAssignmentDto[];
  selectedMeals: CalendarSelectionDto[];
  onToggleMeal: (dayOfWeek: number, mealType: MealType) => void;
}

const DAY_NAMES = ["Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota", "Niedziela"];
const DAY_NAMES_SHORT = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Ndz"];

/**
 * Selektor kalendarza z checkboxami (7 dni × 4 posiłki)
 */
export default function CalendarSelector({ assignments, selectedMeals, onToggleMeal }: CalendarSelectorProps) {
  /**
   * Sprawdza czy posiłek jest zaznaczony
   */
  const isMealSelected = (dayOfWeek: number, mealType: MealType): boolean => {
    const day = selectedMeals.find((m) => m.day_of_week === dayOfWeek);
    return day ? day.meal_types.includes(mealType) : false;
  };

  /**
   * Znajduje przypisanie dla danego dnia i posiłku
   */
  const getAssignment = (dayOfWeek: number, mealType: MealType): MealPlanAssignmentDto | null => {
    return assignments.find((a) => a.day_of_week === dayOfWeek && a.meal_type === mealType) || null;
  };

  return (
    <div className="calendar-selector border rounded-lg p-4 bg-white">
      {/* Desktop: Grid 7 columns */}
      <div className="hidden md:grid md:grid-cols-7 gap-2">
        {[1, 2, 3, 4, 5, 6, 7].map((dayOfWeek) => (
          <div key={dayOfWeek} className="day-column">
            <div className="font-medium text-sm mb-2 text-center">
              <div className="hidden lg:block">{DAY_NAMES[dayOfWeek - 1]}</div>
              <div className="lg:hidden">{DAY_NAMES_SHORT[dayOfWeek - 1]}</div>
            </div>

            <div className="space-y-2">
              {MEAL_TYPES.map((mealType) => {
                const assignment = getAssignment(dayOfWeek, mealType);
                const isSelected = isMealSelected(dayOfWeek, mealType);
                const isEmpty = !assignment;

                return (
                  <div
                    key={mealType}
                    className={cn(
                      "meal-checkbox-item p-2 border rounded text-xs transition-colors",
                      isEmpty && "bg-gray-50 text-gray-400",
                      !isEmpty && "hover:bg-gray-50 cursor-pointer",
                      isSelected && !isEmpty && "border-primary bg-primary/5"
                    )}
                    onClick={() => !isEmpty && onToggleMeal(dayOfWeek, mealType)}
                    onKeyDown={(e) => {
                      if (!isEmpty && (e.key === "Enter" || e.key === " ")) {
                        e.preventDefault();
                        onToggleMeal(dayOfWeek, mealType);
                      }
                    }}
                    role="button"
                    tabIndex={isEmpty ? -1 : 0}
                  >
                    <div className="flex items-start gap-2">
                      <Checkbox
                        id={`meal-${dayOfWeek}-${mealType}`}
                        checked={isSelected}
                        onCheckedChange={() => onToggleMeal(dayOfWeek, mealType)}
                        disabled={isEmpty}
                        className="mt-0.5"
                      />
                      <div className="flex-1 min-w-0">
                        <Label
                          htmlFor={`meal-${dayOfWeek}-${mealType}`}
                          className={cn("text-xs cursor-pointer block", isEmpty && "cursor-not-allowed")}
                        >
                          <div className="font-medium">{MEAL_TYPE_LABELS[mealType]}</div>
                          {assignment && (
                            <div className="text-xs truncate text-gray-600 mt-1" title={assignment.recipe_name}>
                              {assignment.recipe_name}
                            </div>
                          )}
                          {isEmpty && <div className="text-xs text-gray-400 mt-1">Brak przepisu</div>}
                        </Label>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {/* Mobile: Lista */}
      <div className="md:hidden space-y-3">
        {[1, 2, 3, 4, 5, 6, 7].map((dayOfWeek) => (
          <div key={dayOfWeek} className="day-section border rounded-lg p-3">
            <h3 className="font-semibold text-sm mb-2">{DAY_NAMES[dayOfWeek - 1]}</h3>
            <div className="space-y-2">
              {MEAL_TYPES.map((mealType) => {
                const assignment = getAssignment(dayOfWeek, mealType);
                const isSelected = isMealSelected(dayOfWeek, mealType);
                const isEmpty = !assignment;

                return (
                  <div
                    key={mealType}
                    className={cn(
                      "meal-checkbox-item p-2 border rounded text-sm transition-colors",
                      isEmpty && "bg-gray-50 text-gray-400",
                      !isEmpty && "hover:bg-gray-50 cursor-pointer",
                      isSelected && !isEmpty && "border-primary bg-primary/5"
                    )}
                    onClick={() => !isEmpty && onToggleMeal(dayOfWeek, mealType)}
                    onKeyDown={(e) => {
                      if (!isEmpty && (e.key === "Enter" || e.key === " ")) {
                        e.preventDefault();
                        onToggleMeal(dayOfWeek, mealType);
                      }
                    }}
                    role="button"
                    tabIndex={isEmpty ? -1 : 0}
                  >
                    <div className="flex items-start gap-3">
                      <Checkbox
                        id={`meal-mobile-${dayOfWeek}-${mealType}`}
                        checked={isSelected}
                        onCheckedChange={() => onToggleMeal(dayOfWeek, mealType)}
                        disabled={isEmpty}
                      />
                      <div className="flex-1 min-w-0">
                        <Label
                          htmlFor={`meal-mobile-${dayOfWeek}-${mealType}`}
                          className={cn("cursor-pointer block", isEmpty && "cursor-not-allowed")}
                        >
                          <div className="font-medium text-sm">{MEAL_TYPE_LABELS[mealType]}</div>
                          {assignment && <div className="text-sm text-gray-600 mt-1">{assignment.recipe_name}</div>}
                          {isEmpty && <div className="text-sm text-gray-400 mt-1">Brak przepisu</div>}
                        </Label>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



================================================
FILE: src/components/wizard/IngredientRow.tsx
================================================
import React from "react";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Trash2 } from "lucide-react";
import type { SaveShoppingListItemDto, IngredientCategory } from "@/types";
import { INGREDIENT_CATEGORIES } from "@/types";

interface IngredientRowProps {
  item: SaveShoppingListItemDto;
  onUpdate: (field: keyof SaveShoppingListItemDto, value: string | number | null | IngredientCategory) => void;
  onRemove: () => void;
}

/**
 * Edytowalny wiersz składnika w preview listy zakupów
 */
export default function IngredientRow({ item, onUpdate, onRemove }: IngredientRowProps) {
  return (
    <div className="ingredient-row flex items-center gap-2 p-3 border rounded-lg bg-white hover:bg-gray-50 transition-colors">
      {/* Checkbox (disabled - tylko dla preview) */}
      <Checkbox checked={false} disabled className="flex-shrink-0" />

      {/* Quantity */}
      <Input
        type="number"
        value={item.quantity ?? ""}
        onChange={(e) => onUpdate("quantity", e.target.value ? Number(e.target.value) : null)}
        className="w-20 flex-shrink-0"
        placeholder="200"
        min="0"
        step="any"
      />

      {/* Unit */}
      <Input
        type="text"
        value={item.unit ?? ""}
        onChange={(e) => onUpdate("unit", e.target.value || null)}
        className="w-20 flex-shrink-0"
        placeholder="g"
        maxLength={50}
      />

      {/* Ingredient name */}
      <Input
        type="text"
        value={item.ingredient_name}
        onChange={(e) => onUpdate("ingredient_name", e.target.value)}
        className="flex-1 min-w-0"
        placeholder="Nazwa składnika"
        maxLength={100}
        required
      />

      {/* Category */}
      <Select value={item.category} onValueChange={(value) => onUpdate("category", value as IngredientCategory)}>
        <SelectTrigger className="w-32 flex-shrink-0">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {INGREDIENT_CATEGORIES.map((cat) => (
            <SelectItem key={cat} value={cat}>
              {cat}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Delete button */}
      <Button variant="ghost" size="icon" onClick={onRemove} aria-label="Usuń składnik" className="flex-shrink-0">
        <Trash2 className="h-4 w-4 text-red-600" />
      </Button>
    </div>
  );
}



================================================
FILE: src/components/wizard/NavigationButtons.tsx
================================================
import React from "react";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight, X } from "lucide-react";

interface NavigationButtonsProps {
  onBack?: () => void;
  onNext?: () => void;
  onCancel?: () => void;
  onSave?: () => void;
  nextDisabled?: boolean;
  nextLabel?: string;
  saveLabel?: string;
  backLabel?: string;
  isSaving?: boolean;
}

/**
 * Komponent nawigacyjny dla kroków wizarda
 */
export default function NavigationButtons({
  onBack,
  onNext,
  onCancel,
  onSave,
  nextDisabled = false,
  nextLabel = "Dalej",
  saveLabel = "Zapisz",
  backLabel = "Wstecz",
  isSaving = false,
}: NavigationButtonsProps) {
  return (
    <div className="flex justify-between mt-8">
      <div>
        {onBack && (
          <Button variant="outline" onClick={onBack}>
            <ChevronLeft className="h-4 w-4 mr-2" />
            {backLabel}
          </Button>
        )}
      </div>

      <div className="flex gap-2">
        {onCancel && (
          <Button variant="ghost" onClick={onCancel}>
            <X className="h-4 w-4 mr-2" />
            Anuluj
          </Button>
        )}

        {onNext && (
          <Button onClick={onNext} disabled={nextDisabled}>
            {nextLabel}
            <ChevronRight className="h-4 w-4 ml-2" />
          </Button>
        )}

        {onSave && (
          <Button onClick={onSave} disabled={isSaving}>
            {isSaving ? "Zapisywanie..." : saveLabel}
          </Button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/wizard/SaveListDialog.tsx
================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import type { ShoppingListPreviewMetadataDto } from "@/types";
import { format } from "date-fns";
import { pl } from "date-fns/locale";

interface SaveListDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (name: string) => Promise<void>;
  metadata: ShoppingListPreviewMetadataDto | null;
}

/**
 * Dialog zapisywania listy zakupów
 */
export default function SaveListDialog({ isOpen, onClose, onSave, metadata }: SaveListDialogProps) {
  const [listName, setListName] = useState("");
  const [isSaving, setIsSaving] = useState(false);

  // Ustaw domyślną nazwę po otwarciu dialogu
  useEffect(() => {
    if (isOpen) {
      setListName(getDefaultName(metadata));
    }
  }, [isOpen, metadata]);

  const handleSave = async () => {
    if (!listName.trim()) return;

    setIsSaving(true);
    try {
      await onSave(listName.trim());
      onClose();
    } finally {
      setIsSaving(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && listName.trim() && !isSaving) {
      handleSave();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Zapisz listę zakupów</DialogTitle>
          <DialogDescription>Podaj nazwę dla listy zakupów</DialogDescription>
        </DialogHeader>

        <div className="py-4">
          <Label htmlFor="list-name">Nazwa listy</Label>
          <Input
            id="list-name"
            value={listName}
            onChange={(e) => setListName(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={getDefaultName(metadata)}
            maxLength={200}
            disabled={isSaving}
            className="mt-2"
          />
          <p className="text-sm text-gray-600 mt-1">{listName.length}/200 znaków</p>
        </div>

        <DialogFooter>
          <Button variant="ghost" onClick={onClose} disabled={isSaving}>
            Anuluj
          </Button>
          <Button onClick={handleSave} disabled={isSaving || !listName.trim()}>
            {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin" aria-hidden="true" />}
            Zapisz
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Generuje domyślną nazwę listy zakupów
 */
function getDefaultName(metadata: ShoppingListPreviewMetadataDto | null): string {
  if (metadata?.source === "calendar" && metadata.week_start_date) {
    return `Lista zakupów - tydzień ${formatWeekRange(metadata.week_start_date)}`;
  }
  return `Lista zakupów - ${format(new Date(), "d MMMM yyyy", { locale: pl })}`;
}

/**
 * Formatuje zakres tygodnia (np. "20-26 stycznia")
 */
function formatWeekRange(weekStartDate: string): string {
  const startDate = new Date(weekStartDate);
  const endDate = new Date(startDate);
  endDate.setDate(endDate.getDate() + 6);

  const startDay = startDate.getDate();
  const endDay = endDate.getDate();
  const month = format(startDate, "MMMM", { locale: pl });

  return `${startDay}-${endDay} ${month}`;
}



================================================
FILE: src/components/wizard/SelectionCounter.tsx
================================================
import React from "react";
import { Badge } from "@/components/ui/badge";

interface SelectionCounterProps {
  count: number;
  label: string;
  max?: number;
}

/**
 * Komponent wyświetlający licznik zaznaczonych elementów
 */
export default function SelectionCounter({ count, label, max }: SelectionCounterProps) {
  const isAtMax = max !== undefined && count >= max;

  return (
    <div className="selection-counter flex items-center gap-2">
      <span className="text-sm text-gray-600">Wybrano:</span>
      <Badge variant={count > 0 ? "default" : "secondary"} className="text-sm">
        {count} {label}
        {max !== undefined && ` / ${max}`}
      </Badge>
      {isAtMax && <span className="text-sm text-orange-600 font-medium">Osiągnięto maksimum</span>}
    </div>
  );
}



================================================
FILE: src/components/wizard/ShoppingListPreview.tsx
================================================
import React from "react";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ChevronDown, Plus } from "lucide-react";
import type { SaveShoppingListItemDto, IngredientCategory } from "@/types";
import { CATEGORY_ORDER } from "@/types";
import IngredientRow from "./IngredientRow";

interface ShoppingListPreviewProps {
  items: SaveShoppingListItemDto[];
  onUpdateItem: (index: number, field: string, value: string | number | null | IngredientCategory) => void;
  onRemoveItem: (index: number) => void;
  onAddItem: () => void;
}

/**
 * Preview listy zakupów z grupowaniem po kategoriach
 */
export default function ShoppingListPreview({
  items,
  onUpdateItem,
  onRemoveItem,
  onAddItem,
}: ShoppingListPreviewProps) {
  /**
   * Grupuje składniki po kategoriach
   */
  const itemsByCategory = React.useMemo(() => {
    const grouped: Record<IngredientCategory, SaveShoppingListItemDto[]> = {
      Nabiał: [],
      Warzywa: [],
      Owoce: [],
      Mięso: [],
      Pieczywo: [],
      Przyprawy: [],
      Inne: [],
    };

    items.forEach((item) => {
      grouped[item.category].push(item);
    });

    return grouped;
  }, [items]);

  /**
   * Znajduje globalny indeks składnika (potrzebny do onUpdateItem/onRemoveItem)
   */
  const getGlobalIndex = (item: SaveShoppingListItemDto): number => {
    return items.indexOf(item);
  };

  return (
    <div className="shopping-list-preview space-y-4">
      {CATEGORY_ORDER.map((category) => {
        const categoryItems = itemsByCategory[category];

        if (categoryItems.length === 0) return null;

        return (
          <Collapsible key={category} defaultOpen className="border rounded-lg">
            <CollapsibleTrigger className="flex items-center justify-between w-full p-4 bg-gray-50 hover:bg-gray-100 transition-colors rounded-t-lg [&[data-state=closed]_.chevron]:rotate-180">
              <div className="flex items-center gap-3">
                <ChevronDown className="chevron h-4 w-4 transition-transform duration-200" />
                <h3 className="font-semibold text-lg">{category}</h3>
                <Badge variant="secondary">{categoryItems.length}</Badge>
              </div>
            </CollapsibleTrigger>

            <CollapsibleContent className="p-4 pt-2">
              <div className="space-y-2">
                {categoryItems.map((item) => {
                  const globalIndex = getGlobalIndex(item);
                  return (
                    <IngredientRow
                      key={globalIndex}
                      item={item}
                      onUpdate={(field, value) => onUpdateItem(globalIndex, field, value)}
                      onRemove={() => onRemoveItem(globalIndex)}
                    />
                  );
                })}
              </div>
            </CollapsibleContent>
          </Collapsible>
        );
      })}

      {items.length === 0 && (
        <div className="text-center py-12 border rounded-lg bg-gray-50">
          <p className="text-gray-600">Brak składników na liście</p>
        </div>
      )}

      <Button variant="outline" onClick={onAddItem} className="w-full">
        <Plus className="h-4 w-4 mr-2" />
        Dodaj składnik
      </Button>
    </div>
  );
}



================================================
FILE: src/components/wizard/ShoppingListWizard.tsx
================================================
import React, { useReducer, useCallback } from "react";
import type {
  CalendarSelectionDto,
  ShoppingListItemPreviewDto,
  ShoppingListPreviewMetadataDto,
  SaveShoppingListItemDto,
  ShoppingListPreviewRequestDto,
  ShoppingListPreviewResponseDto,
  SaveShoppingListDto,
  MealType,
  IngredientCategory,
} from "@/types";
import WizardHeader from "./WizardHeader";
import Step1_ModeSelection from "./Step1_ModeSelection";
import Step2a_CalendarSelection from "./Step2a_CalendarSelection";
import Step2b_RecipesSelection from "./Step2b_RecipesSelection";
import Step3_Generation from "./Step3_Generation";
import Step4_PreviewEdit from "./Step4_PreviewEdit";
import { toast } from "sonner";

/**
 * Stan wizarda
 */
interface WizardState {
  currentStep: 1 | 2 | 3 | 4;
  mode: "calendar" | "recipes" | null;

  // Step 2a state (calendar)
  selectedMeals: CalendarSelectionDto[];

  // Step 2b state (recipes)
  selectedRecipes: string[];

  // Step 3 state (generation)
  generationStatus: "idle" | "fetching" | "categorizing" | "done" | "error";
  generationProgress: number;

  // Step 4 state (preview)
  previewItems: ShoppingListItemPreviewDto[];
  previewMetadata: ShoppingListPreviewMetadataDto | null;

  // Modified items (for save)
  modifiedItems: SaveShoppingListItemDto[];
}

/**
 * Akcje reducera
 */
type WizardAction =
  | { type: "GO_TO_STEP"; payload: 1 | 2 | 3 | 4 }
  | { type: "SET_MODE"; payload: "calendar" | "recipes" }
  | { type: "TOGGLE_MEAL"; payload: { dayOfWeek: number; mealType: MealType } }
  | { type: "SELECT_ALL_MEALS"; payload: CalendarSelectionDto[] }
  | { type: "TOGGLE_RECIPE"; payload: string }
  | { type: "SET_GENERATION_STATUS"; payload: { status: WizardState["generationStatus"]; progress: number } }
  | { type: "SET_PREVIEW_DATA"; payload: ShoppingListPreviewResponseDto }
  | {
      type: "UPDATE_ITEM";
      payload: { index: number; field: string; value: string | number | null | IngredientCategory };
    }
  | { type: "REMOVE_ITEM"; payload: number }
  | { type: "ADD_ITEM"; payload: SaveShoppingListItemDto }
  | { type: "RESET" };

/**
 * Initial state
 */
const initialState: WizardState = {
  currentStep: 1,
  mode: null,
  selectedMeals: [],
  selectedRecipes: [],
  generationStatus: "idle",
  generationProgress: 0,
  previewItems: [],
  previewMetadata: null,
  modifiedItems: [],
};

/**
 * Reducer dla zarządzania stanem wizarda
 */
function wizardReducer(state: WizardState, action: WizardAction): WizardState {
  switch (action.type) {
    case "GO_TO_STEP":
      return { ...state, currentStep: action.payload };

    case "SET_MODE":
      return { ...state, mode: action.payload };

    case "TOGGLE_MEAL": {
      const { dayOfWeek, mealType } = action.payload;
      const existingDay = state.selectedMeals.find((m) => m.day_of_week === dayOfWeek);

      if (existingDay) {
        const hasMealType = existingDay.meal_types.includes(mealType);

        if (hasMealType) {
          // Remove meal type
          const updatedMealTypes = existingDay.meal_types.filter((m) => m !== mealType);

          if (updatedMealTypes.length === 0) {
            // Remove entire day if no meal types left
            return {
              ...state,
              selectedMeals: state.selectedMeals.filter((m) => m.day_of_week !== dayOfWeek),
            };
          } else {
            // Update meal types for this day
            return {
              ...state,
              selectedMeals: state.selectedMeals.map((m) =>
                m.day_of_week === dayOfWeek ? { ...m, meal_types: updatedMealTypes } : m
              ),
            };
          }
        } else {
          // Add meal type to existing day
          return {
            ...state,
            selectedMeals: state.selectedMeals.map((m) =>
              m.day_of_week === dayOfWeek ? { ...m, meal_types: [...m.meal_types, mealType] } : m
            ),
          };
        }
      } else {
        // Add new day with meal type
        return {
          ...state,
          selectedMeals: [...state.selectedMeals, { day_of_week: dayOfWeek, meal_types: [mealType] }],
        };
      }
    }

    case "SELECT_ALL_MEALS":
      return { ...state, selectedMeals: action.payload };

    case "TOGGLE_RECIPE": {
      const recipeId = action.payload;
      const isSelected = state.selectedRecipes.includes(recipeId);

      return {
        ...state,
        selectedRecipes: isSelected
          ? state.selectedRecipes.filter((id) => id !== recipeId)
          : [...state.selectedRecipes, recipeId],
      };
    }

    case "SET_GENERATION_STATUS":
      return {
        ...state,
        generationStatus: action.payload.status,
        generationProgress: action.payload.progress,
      };

    case "SET_PREVIEW_DATA":
      return {
        ...state,
        previewItems: action.payload.items,
        previewMetadata: action.payload.metadata,
        modifiedItems: action.payload.items.map((item) => ({
          ingredient_name: item.ingredient_name,
          quantity: item.quantity,
          unit: item.unit,
          category: item.category,
          sort_order: item.sort_order,
        })),
      };

    case "UPDATE_ITEM": {
      const { index, field, value } = action.payload;
      return {
        ...state,
        modifiedItems: state.modifiedItems.map((item, i) => (i === index ? { ...item, [field]: value } : item)),
      };
    }

    case "REMOVE_ITEM":
      return {
        ...state,
        modifiedItems: state.modifiedItems.filter((_, i) => i !== action.payload),
      };

    case "ADD_ITEM":
      return {
        ...state,
        modifiedItems: [...state.modifiedItems, action.payload],
      };

    case "RESET":
      return initialState;

    default:
      return state;
  }
}

/**
 * Główny komponent wizarda Shopping List Generate
 */
export default function ShoppingListWizard() {
  const [state, dispatch] = useReducer(wizardReducer, initialState);

  /**
   * Przejście do określonego kroku
   */
  const goToStep = useCallback((step: 1 | 2 | 3 | 4) => {
    dispatch({ type: "GO_TO_STEP", payload: step });
  }, []);

  /**
   * Wybór trybu generowania
   */
  const selectMode = useCallback((mode: "calendar" | "recipes") => {
    dispatch({ type: "SET_MODE", payload: mode });
  }, []);

  /**
   * Toggle zaznaczenia posiłku (calendar mode)
   */
  const toggleMeal = useCallback((dayOfWeek: number, mealType: MealType) => {
    dispatch({ type: "TOGGLE_MEAL", payload: { dayOfWeek, mealType } });
  }, []);

  /**
   * Zaznacz wszystkie posiłki
   */
  const selectAllMeals = useCallback((selections: CalendarSelectionDto[]) => {
    dispatch({ type: "SELECT_ALL_MEALS", payload: selections });
  }, []);

  /**
   * Toggle zaznaczenia przepisu (recipes mode)
   */
  const toggleRecipe = useCallback((recipeId: string) => {
    dispatch({ type: "TOGGLE_RECIPE", payload: recipeId });
  }, []);

  /**
   * Generuj preview listy zakupów
   */
  const generatePreview = useCallback(async () => {
    dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "fetching", progress: 0 } });

    try {
      // Przygotuj request body
      const requestBody: ShoppingListPreviewRequestDto =
        state.mode === "calendar"
          ? {
              source: "calendar",
              week_start_date: getCurrentWeekStart(),
              selections: state.selectedMeals,
            }
          : {
              source: "recipes",
              recipe_ids: state.selectedRecipes,
            };

      // Symulacja progress
      dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "fetching", progress: 40 } });

      // POST /api/shopping-lists/preview
      const response = await fetch("/api/shopping-lists/preview", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
      });

      dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "categorizing", progress: 70 } });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Nie udało się wygenerować listy");
      }

      const data: ShoppingListPreviewResponseDto = await response.json();

      dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "categorizing", progress: 90 } });

      // Ustaw dane preview
      dispatch({ type: "SET_PREVIEW_DATA", payload: data });

      dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "done", progress: 100 } });

      // Automatyczne przejście do step 4
      setTimeout(() => {
        goToStep(4);
      }, 500);
    } catch (error) {
      console.error("Generation error:", error);
      dispatch({ type: "SET_GENERATION_STATUS", payload: { status: "error", progress: 0 } });
      toast.error(error instanceof Error ? error.message : "Nie udało się wygenerować listy");
    }
  }, [state.mode, state.selectedMeals, state.selectedRecipes, goToStep]);

  /**
   * Aktualizuj składnik w preview
   */
  const updateItem = useCallback((index: number, field: string, value: string | number | null | IngredientCategory) => {
    dispatch({ type: "UPDATE_ITEM", payload: { index, field, value } });
  }, []);

  /**
   * Usuń składnik z preview
   */
  const removeItem = useCallback((index: number) => {
    dispatch({ type: "REMOVE_ITEM", payload: index });
  }, []);

  /**
   * Dodaj składnik do preview
   */
  const addItem = useCallback((item: SaveShoppingListItemDto) => {
    dispatch({ type: "ADD_ITEM", payload: item });
  }, []);

  /**
   * Zapisz listę zakupów
   */
  const saveList = useCallback(
    async (name: string) => {
      try {
        const requestBody: SaveShoppingListDto = {
          name,
          week_start_date: state.mode === "calendar" ? state.previewMetadata?.week_start_date || null : null,
          items: state.modifiedItems,
        };

        const response = await fetch("/api/shopping-lists", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Nie udało się zapisać listy");
        }

        const savedList = await response.json();

        toast.success("Lista zakupów została zapisana");

        // Przekieruj do widoku szczegółów listy (używamy window.location w Astro)
        window.location.href = `/shopping-lists/${savedList.id}`;
      } catch (error) {
        console.error("Save error:", error);
        toast.error(error instanceof Error ? error.message : "Nie udało się zapisać listy");
        throw error;
      }
    },
    [state.mode, state.modifiedItems, state.previewMetadata]
  );

  return (
    <div className="wizard">
      <WizardHeader currentStep={state.currentStep} />

      {state.currentStep === 1 && (
        <Step1_ModeSelection selectedMode={state.mode} onSelectMode={selectMode} onNext={() => goToStep(2)} />
      )}

      {state.currentStep === 2 && state.mode === "calendar" && (
        <Step2a_CalendarSelection
          selectedMeals={state.selectedMeals}
          onToggleMeal={toggleMeal}
          onSelectAllMeals={selectAllMeals}
          onBack={() => goToStep(1)}
          onNext={() => {
            goToStep(3);
            generatePreview();
          }}
        />
      )}

      {state.currentStep === 2 && state.mode === "recipes" && (
        <Step2b_RecipesSelection
          selectedRecipes={state.selectedRecipes}
          onToggleRecipe={toggleRecipe}
          onBack={() => goToStep(1)}
          onNext={() => {
            goToStep(3);
            generatePreview();
          }}
        />
      )}

      {state.currentStep === 3 && (
        <Step3_Generation status={state.generationStatus} progress={state.generationProgress} />
      )}

      {state.currentStep === 4 && (
        <Step4_PreviewEdit
          items={state.modifiedItems}
          metadata={state.previewMetadata}
          onUpdateItem={updateItem}
          onRemoveItem={removeItem}
          onAddItem={addItem}
          onBack={() => goToStep(2)}
          onCancel={() => (window.location.href = "/shopping-lists")}
          onSave={saveList}
        />
      )}
    </div>
  );
}

/**
 * Pomocnicza funkcja do pobrania początku aktualnego tygodnia
 */
function getCurrentWeekStart(): string {
  const today = new Date();
  const dayOfWeek = today.getDay();
  const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Poniedziałek = 1
  const monday = new Date(today);
  monday.setDate(today.getDate() + diff);

  const year = monday.getFullYear();
  const month = String(monday.getMonth() + 1).padStart(2, "0");
  const day = String(monday.getDate()).padStart(2, "0");

  return `${year}-${month}-${day}`;
}



================================================
FILE: src/components/wizard/Step1_ModeSelection.tsx
================================================
import React from "react";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { ChevronRight, Calendar, BookOpen } from "lucide-react";
import { cn } from "@/lib/utils";

interface Step1_ModeSelectionProps {
  selectedMode: "calendar" | "recipes" | null;
  on
</kod_projektu>

<struktura_projektu>
Directory structure:
└── src/
    ├── env.d.ts
    ├── types.ts
    ├── components/
    │   ├── Calendar.tsx
    │   ├── CalendarGrid.tsx
    │   ├── MealCell.tsx
    │   ├── Navigation.tsx
    │   ├── RecipePickerModal.tsx
    │   ├── RecipePreviewModal.tsx
    │   ├── SearchBar.tsx
    │   ├── ShoppingListGenerateView.tsx
    │   ├── WeekNavigator.tsx
    │   ├── Welcome.astro
    │   ├── auth/
    │   │   ├── LoginView.tsx
    │   │   ├── RegisterView.tsx
    │   │   └── ResetPasswordView.tsx
    │   ├── dashboard/
    │   │   ├── ActionButton.tsx
    │   │   ├── DashboardHeader.tsx
    │   │   ├── DashboardSkeleton.tsx
    │   │   ├── DashboardView.tsx
    │   │   ├── EmptyState.tsx
    │   │   ├── ErrorMessage.tsx
    │   │   ├── MealItem.tsx
    │   │   ├── QuickActionsSection.tsx
    │   │   ├── RecentRecipesSection.tsx
    │   │   ├── RecipeCard.tsx
    │   │   ├── StatCard.tsx
    │   │   ├── StatsSection.tsx
    │   │   └── UpcomingMealsSection.tsx
    │   ├── hooks/
    │   │   ├── useCalendar.ts
    │   │   ├── useDashboard.ts
    │   │   ├── useDebouncedValue.ts
    │   │   ├── useRecipeSearch.ts
    │   │   ├── useRecipesList.ts
    │   │   └── useWeekNavigation.ts
    │   ├── providers/
    │   │   └── QueryProvider.tsx
    │   ├── recipes/
    │   │   ├── AddRecipeButton.tsx
    │   │   ├── AssignmentsInfo.tsx
    │   │   ├── DeleteConfirmationDialog.tsx
    │   │   ├── DiscardChangesDialog.tsx
    │   │   ├── EmptyState.tsx
    │   │   ├── ErrorMessage.tsx
    │   │   ├── FormActions.tsx
    │   │   ├── FormHeader.tsx
    │   │   ├── IngredientRow.tsx
    │   │   ├── IngredientsList.tsx
    │   │   ├── IngredientsSection.tsx
    │   │   ├── InstructionsSection.tsx
    │   │   ├── InstructionsTextarea.tsx
    │   │   ├── NameInput.tsx
    │   │   ├── RecipeCard.tsx
    │   │   ├── RecipeCardSkeleton.tsx
    │   │   ├── RecipeCreateView.tsx
    │   │   ├── RecipeDetailsContent.tsx
    │   │   ├── RecipeDetailsHeader.tsx
    │   │   ├── RecipeDetailsSkeleton.tsx
    │   │   ├── RecipeDetailsView.tsx
    │   │   ├── RecipeEditView.tsx
    │   │   ├── RecipeForm.tsx
    │   │   ├── RecipeMeta.tsx
    │   │   ├── RecipesGrid.tsx
    │   │   ├── RecipesGridSkeleton.tsx
    │   │   ├── RecipesHeader.tsx
    │   │   ├── RecipesListView.tsx
    │   │   ├── RecipesListViewWrapper.tsx
    │   │   ├── SearchBar.tsx
    │   │   └── SortDropdown.tsx
    │   ├── shopping-lists/
    │   │   ├── CategoriesAccordion.tsx
    │   │   ├── DeleteConfirmationDialog.tsx
    │   │   ├── EmptyState.tsx
    │   │   ├── IngredientItem.tsx
    │   │   ├── ListMeta.tsx
    │   │   ├── PDFPreviewModal.tsx
    │   │   ├── ShoppingListCard.tsx
    │   │   ├── ShoppingListDetailsContent.tsx
    │   │   ├── ShoppingListDetailsSkeleton.tsx
    │   │   ├── ShoppingListDetailsView.tsx
    │   │   ├── ShoppingListHeader.tsx
    │   │   ├── ShoppingListsGrid.tsx
    │   │   ├── ShoppingListsGridSkeleton.tsx
    │   │   ├── ShoppingListsHeader.tsx
    │   │   └── ShoppingListsHistoryView.tsx
    │   ├── ui/
    │   │   ├── accordion.tsx
    │   │   ├── alert.tsx
    │   │   ├── badge.tsx
    │   │   ├── breadcrumb.tsx
    │   │   ├── button.tsx
    │   │   ├── checkbox.tsx
    │   │   ├── collapsible.tsx
    │   │   ├── dialog.tsx
    │   │   ├── input.tsx
    │   │   ├── label.tsx
    │   │   ├── progress.tsx
    │   │   ├── radio-group.tsx
    │   │   ├── scroll-area.tsx
    │   │   ├── select.tsx
    │   │   ├── skeleton.tsx
    │   │   ├── textarea.tsx
    │   │   └── toaster.tsx
    │   └── wizard/
    │       ├── CalendarSelector.tsx
    │       ├── IngredientRow.tsx
    │       ├── NavigationButtons.tsx
    │       ├── SaveListDialog.tsx
    │       ├── SelectionCounter.tsx
    │       ├── ShoppingListPreview.tsx
    │       ├── ShoppingListWizard.tsx
    │       ├── Step1_ModeSelection.tsx
    │       ├── Step2a_CalendarSelection.tsx
    │       ├── Step2b_RecipesSelection.tsx
    │       ├── Step3_Generation.tsx
    │       ├── Step4_PreviewEdit.tsx
    │       └── WizardHeader.tsx
    ├── db/
    │   ├── database.types.ts
    │   └── supabase.client.ts
    ├── layouts/
    │   ├── AuthLayout.astro
    │   └── Layout.astro
    ├── lib/
    │   ├── utils.ts
    │   ├── api/
    │   │   ├── meal-plan.ts
    │   │   └── recipes.ts
    │   ├── pdf-export/
    │   │   └── ShoppingListPDFDocument.tsx
    │   ├── services/
    │   │   ├── ai-categorization.service.ts
    │   │   ├── analytics.service.ts
    │   │   ├── meal-plan.service.ts
    │   │   ├── recipe.service.ts
    │   │   ├── shopping-list-preview.service.ts
    │   │   ├── shopping-list.service.ts
    │   │   └── openrouter/
    │   │       ├── README.md
    │   │       ├── index.ts
    │   │       ├── openrouter.service.ts
    │   │       └── types.ts
    │   ├── utils/
    │   │   ├── auth-errors.ts
    │   │   ├── calendar.ts
    │   │   ├── date.ts
    │   │   ├── export.ts
    │   │   └── text.ts
    │   └── validation/
    │       ├── analytics.schema.ts
    │       ├── auth.schema.ts
    │       ├── meal-plan.schema.ts
    │       ├── recipe.schema.ts
    │       └── shopping-list.schema.ts
    ├── middleware/
    │   └── index.ts
    ├── pages/
    │   ├── calendar.astro
    │   ├── dashboard.astro
    │   ├── index.astro
    │   ├── login.astro
    │   ├── register.astro
    │   ├── reset-password.astro
    │   ├── api/
    │   │   ├── ai/
    │   │   │   └── categorize-ingredients.ts
    │   │   ├── analytics/
    │   │   │   └── export.ts
    │   │   ├── auth/
    │   │   │   ├── login.ts
    │   │   │   ├── logout.ts
    │   │   │   ├── register.ts
    │   │   │   ├── reset-password.ts
    │   │   │   └── update-password.ts
    │   │   ├── meal-plan/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── recipes/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   └── shopping-lists/
    │   │       ├── [id].ts
    │   │       ├── index.ts
    │   │       ├── preview.ts
    │   │       └── [list_id]/
    │   │           └── items/
    │   │               └── [item_id].ts
    │   ├── recipes/
    │   │   ├── [id].astro
    │   │   ├── index.astro
    │   │   ├── new.astro
    │   │   └── [id]/
    │   │       └── edit.astro
    │   └── shopping-lists/
    │       ├── [id].astro
    │       ├── generate.astro
    │       └── index.astro
    └── styles/
        └── global.css

</struktura_projektu>


Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:
- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown
